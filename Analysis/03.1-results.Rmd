---
title: "Bird beak's elaboration and innovation"
author: "Thomas Guillerme"
date: "`r Sys.Date()`"
bibliography: references.bib
output:
  html_document:
    fig_width: 8
    fig_height: 8
---

This section contains the code for reproducing the analyses. To get the details, refer to 03-elaboration_innovation_analyses.Rmd.

```{r, eval = TRUE, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE, print = FALSE}
library(dispRity)
```

# All birds shapespace analyses

```{r, eval = TRUE, echo = FALSE}
## Load the data
load(file = "../Data/Processed/shapespace_allbirds_lvl_superorder_order.rda")
## Select the data
shapespace <- shapespace_allbirds_lvl_superorder_order[[1]]$space
tree <- shapespace_allbirds_lvl_superorder_order[[1]]$consensus_tree
## Clean garbage
rm(shapespace_allbirds_lvl_superorder_order)

## Load the covar
load(file = "../Data/Processed/shapespace_allbirds_lvl_superorder_order.MCMCglmm")
shapespace_allbirds_lvl_superorder_order <- shapespace_allbirds_lvl_superorder_order[[1]]

## Get the levels
phylo_lvl <- which(MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order) == "animal")
super_lvl <- grep("level1_", MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order))
order_lvl <- grep("level2_", MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order))

## Creating the subsets
superorder_shapespace <- MCMCglmm.subsets(n = 1000, # Just run it on 1k matrices for now
      data          = shapespace,
      posteriors    = shapespace_allbirds_lvl_superorder_order,
      group         = MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order)[c(super_lvl, phylo_lvl)],
      rename.groups = c(levels(shapespace$level1)[-1], "phylogeny")) #[-1] is because the first level is ""

order_shapespace <- MCMCglmm.subsets(n = 1000, # Just run it on 1k matrices for now
      data          = shapespace,
      posteriors    = shapespace_allbirds_lvl_superorder_order,
      group         = MCMCglmm.levels(shapespace_allbirds_lvl_superorder_order)[c(order_lvl, phylo_lvl)],
      rename.groups = c(levels(shapespace$level2)[-1], "phylogeny")) #[-1] is because the first level is ""
## Clean garbage
rm(shapespace_allbirds_lvl_superorder_order)
```

First we can visualise the global bird shape space (or at least the 2 first of the 8 dimensions):

```{r, message = FALSE, warning = FALSE, fig.height = 8, fig.width = 8, echo = FALSE}
## Plotting just the space
covar.plot(superorder_shapespace,
           main = "Shapespace",
           cex = 0.5,
           legend = TRUE,
           col = c(rainbow(n.subsets(superorder_shapespace)-1), "grey"),
           legend.args = list(x = "bottomright", cex = 2/3))
```

Figure: The global shape space


We can then check the distribution of the variance covariance matrices for each super order and each order.
The VCV matrices are represented as average ellipses or average axis.

```{r, echo = FALSE, fig.height = 14, fig.width = 14, eval = TRUE}
par(mfrow = c(2,2))
## Plotting mean axes
covar.plot(superorder_shapespace,
           col = c(rainbow(n.subsets(superorder_shapespace)-1), "grey"),
           main = "Average ellipses by super order",
           ellipses = mean,
           legend = FALSE,
           points = FALSE,
           cex = 0.5)
## Plotting mean ellipses
covar.plot(superorder_shapespace,
           col = c(rainbow(n.subsets(superorder_shapespace)-1), "grey"),
           main = "Average major axes by super order",
           major.axes = mean,
           legend = TRUE,
           points = FALSE,
           cex = 0.5)
covar.plot(order_shapespace,
           col = c(rainbow(n.subsets(order_shapespace)-1), "grey"),
           main = "Average ellipses by order",
           ellipses = mean,
           legend = FALSE,
           points = FALSE,
           cex = 0.5)
## Plotting mean ellipses
covar.plot(order_shapespace,
           col = c(rainbow(n.subsets(order_shapespace)-1), "grey"),
           main = "Average major axes by order",
           major.axes = mean,
           legend = TRUE,
           points = FALSE,
           cex = 0.5)
```

Main axes and ellipses visualisation for each superorders and orders.

### Are these 2D average ellipses and/or axes an accurate representation of what's going on? 
<details>
  <summary>[Click to expand] TL;DR: It depends...
</summary>
  
A couple of things have to be taken into account:

 * First, the averaging of the VCV (and it's ellipse and/or maon axis) can result into weird "middle" VCV that are not representing the individual VCV (e.g. if half VCV are negative, and half positive, the average will be probably 0; which does not exist).
 * Second, the ellipses in nD projected onto a 2D space will be deformed (unless the VCV is a real pancake on the first 2D, i.e. with no variance on the other dimensions).

Note that both problems are only visual though since: 1) we don't use averages anywhere (but the full distributions all the time) and 2) the linear algebra bit with the projections and stuff works in any number of dimensions and transforms the results into 1D results (i.e. the projection/rejection of groups/species on the major axes in 8D space).

Here's a visualisation of how the variance in VCVs affects the averaging artefact:

```{r, eval = TRUE, echo = FALSE}
visualisation.group <- function(data, subset, dimensions, n = 100) {

    ## Get the subset
    sub <- get.subsets(data, subsets = subset)

    ## Make 2D
    if(!missing(dimensions)) {
        sub$matrix[[1]] <- sub$matrix[[1]][,dimensions]
        sub$call$dimensions <- dimensions
        fun2d <- function(covar) {
            covar$VCV <- covar$VCV[dimensions, dimensions]
            covar$loc <- covar$loc[dimensions]
            return(covar)
        }
        sub$covar <- lapply(sub$covar, lapply, fun2d)
        main_D <- "2D"
    } else {
        main_D <- "8D"
    }

    ## Make the tile
    main <- paste0(n, " random ", subset, " VCV (", main_D, ")")

    ## Plot
    covar.plot(sub, major.axes = TRUE, ellipses = TRUE, points = FALSE, legend = FALSE, main = main)
    covar.plot(sub, major.axes = mean, ellipses = mean, points = FALSE, col = "red", add = TRUE)
    rm(sub)
}

visualisation.group(superorder_shapespace, "Mirandornithes")
```

```{r, echo = FALSE, eval = TRUE}
visualisation.group(superorder_shapespace, "Strisores")
```

Or even more obvious (with an direction that does not really exist (due to averaging)):

```{r, echo = FALSE, eval = TRUE}
visualisation.group(superorder_shapespace, "Paleognathae")
```

For the 2Dness, the effect is a bit less obvious (because the two first dimensions already have so much variance). Here is an example for the Columbimorphae. (to check different groups, you can easily modify the source code of the Rmd. TODO: this would be good in some shiny app innovation thingy).


```{r, echo = FALSE, eval = TRUE, fig.height = 6, fig.width = 12}
par(mfrow = c(1,2))
visualisation.group(superorder_shapespace, "Columbimorphae")
visualisation.group(superorder_shapespace, "Columbimorphae", dimensions = c(1,2))
```

Back to the main story.
</details>

## Calculate the elaborations/innovations

We then calculate the projections/rejections as explained in more details in the [03-elaboration_exploration_analyses.Rmd]() script.
Really briefly we calculate three types of projections/rejections abbreviated as follows below:

 * `group on phylogeny`: the projection of each group's VCV (major axis) on the phylogenetic's VCV (major axis)
 * `species on phylogeny`: the projection of each element within a group (species) onto the phylogenetic's VCV (major axis)
 * `species on group`: the projection of each element within a group (species) onto its own VCV (major axis)




<!-- TODO: add the pictures of the different tests here -->


TODO: centre and absolute directly in `dispRity.covar.projections`


```{r, fig.height = 20, fig.width = 10, echo = FALSE, eval = FALSE, results = 'hide', message = FALSE, warning = FALSE}
## Run the analyses between groups
super_results_between <- dispRity.covar.projections(superorder_shapespace,
                                             type = "groups",
                                             base = "phylogeny",
                                             verbose = TRUE,
                                             output = c("position", "distance"), centre.proj = TRUE)
## Run the analyses between groups
order_results_between <- dispRity.covar.projections(order_shapespace,
                                             type = "groups",
                                             base = "phylogeny",
                                             verbose = TRUE,
                                             output = c("position", "distance"), centre.proj = TRUE)
## Run the analyses of groups on the phylogeny
super_results_phylo <- dispRity.covar.projections(superorder_shapespace,
                                            type = "elements",
                                            base = "phylogeny",
                                            inc.base = TRUE,
                                            verbose = TRUE,
                                            output = c("position", "distance"), centre.proj = TRUE)
## Run the analyses of groups on the phylogeny
order_results_phylo <- dispRity.covar.projections(order_shapespace,
                                            type = "elements",
                                            base = "phylogeny",
                                            inc.base = TRUE,
                                            verbose = TRUE,
                                            output = c("position", "distance"), centre.proj = TRUE)
## Run the analyses groups on themselves
super_results_within <- dispRity.covar.projections(superorder_shapespace,
                                            type = "elements",
                                            verbose = TRUE,
                                            output = c("position", "distance"), centre.proj = TRUE)
## Run the analyses groups on themselves
order_results_within <- dispRity.covar.projections(order_shapespace,
                                            type = "elements",
                                            verbose = TRUE,
                                            output = c("position", "distance"), centre.proj = TRUE)
shapespace_allbirds_lvl_superorder_order_results_list <- list(
        "super_results_between" = super_results_between,
        "order_results_between" = order_results_between,
        "super_results_phylo"   = super_results_phylo,
        "order_results_phylo"   = order_results_phylo,
        "super_results_within"  = super_results_within,
        "order_results_within"  = order_results_within)
save(shapespace_allbirds_lvl_superorder_order_results_list, file = "../Data/Processed/shapespace_allbirds_lvl_superorder_order_results_list_centred.rda")
```

```{r, echo = FALSE}
## Quick load
# load(file = "../Data/Processed/shapespace_allbirds_lvl_superorder_order_results_list_uncentred.rda")
# results_cent <- shapespace_allbirds_lvl_superorder_order_results_list
load(file = "../Data/Processed/shapespace_allbirds_lvl_superorder_order_results_list_centred.rda")
results <- shapespace_allbirds_lvl_superorder_order_results_list
rm(shapespace_allbirds_lvl_superorder_order_results_list)
```


### Projections of groups on the phylogeny:

```{r "starting with boxplots", echo = FALSE, fig.height = 8, fig.width = 8}
## Plot the results
wrap.plot <- function(results, col, main, names, order = TRUE, xlim = NULL) {

    ## Ranking the results
    if(order) {
        ## Get the ranking
        orders <- lapply(results, get.disparity, concatenate = FALSE)
        ## Get the mean values
        orders_pos <- orders$position
        orders_dis <- orders$distance

        ## Get the mean for each and combine into a table
        cent.tend <- mean
        means <- cbind(unlist(lapply(orders_pos, cent.tend)), unlist(lapply(orders_dis, cent.tend)))

        ## Sum them and rank them
        sum_means <- apply(means, 1, sum)
        rank <- order(sum_means, decreasing = FALSE)
    } else {
        rank <- 1:length(results[[1]]$disparity)
    }


    ## Adding one plot
    one.plot <- function(one_result, xlab, col, zero = TRUE, main, centre, absolute, rank = NULL, xlim = NULL, ...) {
        values <- lapply(get.disparity(one_result, concatenate = FALSE), c)
        if(!is.null(rank)) {
            values <- values[rank]
        }
        if(!is.null(xlim)) {
            xlim <- xlim
        } else {
            xlim <- range(values)
        }

        boxplot(values, horizontal = TRUE, yaxt = "n", col = col, xlab = xlab, main = main, ylim = xlim, ...)
        if(zero) {
            abline(v = 0, col = "black", lty = 3, lwd = 1)
        }
    }

    ## How many sub plots?
    n <- length(results)

    ## Recycle labels?
    if(missing(names)) {
        names_list <-names(results)
    } else {
        names_list <- names
    }

    ## Which will be the centre plot?
    centre <- ceiling(n/2)
    ## Plot everything
    op <- par(mfrow = c(1, n+1))
    ## Plot the first panel
    par(bty = "n", mar = c(5, 14, 4, 0) + 0.1)
    empty <- matrix(0, ncol = length(results[[1]]$disparity))
    colnames(empty) <- names(results[[1]]$disparity)[rank]
    boxplot(empty, horizontal = TRUE, las = 2, col = "white", ylim = c(0,0), xaxt = "n", border = "white")
    for(i in 1:n) {
        ## Is position?
        is_position <- names(results)[[i]] == "position"
        par(mar = c(5, 0, 4, 0) + 0.1, bty = "o")
        one.plot(results[[i]], col = col, centre = is_position && centre.position, main = ifelse(i == centre, main, ""), xlab = names_list[i], zero = FALSE, absolute = absolute, rank = rank, xlim = xlim)
    }
    par(op)
}
wrap.plot(results$super_results_between,
              col = rainbow(n.subsets(superorder_shapespace)-1),
              main = "[groups on phylogeny] superorders VCV\nonto the phylogenetic VCV",
              names = c("elaboration", "innovation"))
```

Figure: these results show the projections ("position"), rejection ("distance") and angles ("degree") of the posteriors of each group's major axes onto the corresponding global phylogenetic major axes. For each panel, the highest the score the more the clade is elaborating, exploring, exploring perpendicular to the main axes for the position, distance and degree respectively.

<details>
  <summary>[Click to expand] Same but zooming on the (0,5) interval (to get less of the flamingo effect)
</summary>

```{r, echo = FALSE, fig.height = 8, fig.width = 8}
wrap.plot(results$super_results_between,
          xlim = c(0,6),
          col = rainbow(n.subsets(superorder_shapespace)-1),
          main = "[groups on phylogeny] superorders VCV\nonto the phylogenetic VCV",
          names = c("elaboration", "innovation"))
```
</details>

```{r, fig.height = 16, fig.width = 8, echo = FALSE}
wrap.plot(results$order_results_between,
          col = rainbow(n.subsets(order_shapespace)-1),
          main = "[groups on phylogeny] orders VCV\nonto the phylogenetic VCV",
          names = c("elaboration", "innovation"))
```

<details>
  <summary>[Click to expand] Again, same but with some zoom (0,15)
</summary>

```{r, echo = FALSE, fig.height = 16, fig.width = 8}
wrap.plot(results$order_results_between,
          xlim = c(0, 15),
          col = rainbow(n.subsets(order_shapespace)-1),
          main = "[groups on phylogeny] orders VCV\nonto the phylogenetic VCV",
          names = c("elaboration", "innovation"))
```
</details>






### Projections of the species on the phylogenetic VCV

Similarly to the analyses described above, we ran the analyses for each species.
Here, instead of projecting the major axes of the groups onto the global phylogenetic major axis we projected each species onto the phylogenetic major axis (for each posterior distribution).

```{r, fig.height = 8, fig.width = 8, echo = FALSE, eval = TRUE}
## Plot the results
wrap.plot(results$super_results_phylo,
          col = rainbow(n.subsets(superorder_shapespace)-1),
          main = "[species on phylogeny] superorders species\nonto the phylogenetic VCV",
          names = c("elaboration", "innovation"))
```

Figure: the projection of each species per group onto the posterior distribution of global major phylogenetic axis.

```{r, fig.height = 16, fig.width = 8, echo = FALSE}
## Plot the results
wrap.plot(results$order_results_phylo,
          col = rainbow(n.subsets(order_shapespace)-1),
          main = "[species on phylogeny] orders species\nonto the phylogenetic VCV",
          names = c("elaboration", "innovation"))
```

### Projections of the species on their own group's VCV

Finally, we ran the same analyses but instead of the projection of the species onto the global phylogenetic major axes, we projected them onto their respective group's phylogenetic major axes.


```{r, fig.height = 8, fig.width = 8, echo = FALSE}
## Plot the results
wrap.plot(results$super_results_within,
          col = rainbow(n.subsets(superorder_shapespace)-1),
          main = "[species on group] superorders species\nonto their group's VCV",
          names = c("elaboration", "innovation"))
```

Figure: the projection of each species per group onto the posterior distribution of each clade's major phylogenetic axis (the grey distributions corresponds to the projections of all the species, irregardless of their group, onto the global phylogenetic major axes).


```{r, fig.height = 16, fig.width = 8, echo = FALSE}
## Plot the results
wrap.plot(results$order_results_within,
          col = rainbow(n.subsets(order_shapespace)-1),
          main = "[species on group] orders species\nonto their group's VCV",
          names = c("elaboration", "innovation"))
```


So that's the story so far...


# Different scores distributions per species

```{r, eval = TRUE, echo = FALSE, eval = TRUE}
library(hdrcde)

#@param res the results list
#@param type which type (position, distance or angle)
#@param cent.tend which central tendency fun (default is median)
#@param use.hdr whether to use kernel density estimate for the outputs (default is TRUE)
#@param prob which quantiles to use (default is c(50, 95, 99))
#@param exclude.phylo remove the phylogeny subset (default = FALSE)
#@param add.relative whether to add the relative results (as rel.pos and rel.dis) or not
#@param ... plot options
get.distributions <- function(res, type, cent.tend = median, use.hdr = TRUE, prob = c(50, 95, 99), exclude.phylo = FALSE, add.relative = FALSE, ...) {

    ## Remove the phylo one (if needed)
    if(exclude.phylo) {
        select <- names(size.subsets(res[[type]]))
        select <- select[-which(select %in% "phylogeny")]
        res[[type]] <- get.subsets(res[[type]], subsets = select)
    }
    ## Extracting all the results
    disparity <- lapply(res[[type]]$disparity, function(X, type) return(X$elements))

    ## Measure the central tendencies
    centrals <- lapply(disparity, function(X, fun) apply(X, 1, fun), fun = cent.tend)
    ## Number of groups
    n_groups <- length(centrals)

    ## Calculate and plot the hdrcde
    op_tmp <- par(mfrow = c(ceiling(sqrt(n_groups)), round(sqrt(n_groups))))
    densities <- list()
    for(i in 1:length(centrals)) {
        if(use.hdr) {
            densities[[i]] <- hdr.den(centrals[[i]], prob = prob, main = names(centrals)[i])#, ...)
        } else {
            hist(centrals[[i]], main = names(centrals)[i], ...)
        }
    }
    par(op_tmp)

    ## Find the extreme species
    get.extremes.hdr <- function(density, central) {
        ## Get the minimums and maximums
        mins <- which(central <= density$hdr[1,1])
        maxs <- which(central >= density$hdr[1, ncol(density$hdr)])
        ## Get their values
        return(c(central[names(mins)], central[names(maxs)]))
    }
    CI.converter <- function(CI) {
        sort(c(50-CI/2, 50+CI/2)/100)
    }
    get.extremes.quantile <- function(central, prob) {
        ## Get the quantiles
        quants <- quantile(central, probs = CI.converter(max(prob)))
        ## Get the minimums and maximums
        mins <- which(central <= quants[1])
        maxs <- which(central >= quants[2])
        ## Get their values
        return(c(central[names(mins)], central[names(maxs)]))
    } 

    if(use.hdr) {
        output <- mapply(get.extremes.hdr, densities, centrals, SIMPLIFY = FALSE)
        names(output) <- names(centrals)
    } else {
        output <- lapply(centrals, get.extremes.quantile, prob = prob)
    }

    ## Return the as a table
    for(i in 1:length(output)) {
        if(length(output[[i]]) == 0) {
            output[[i]] <- data.frame("level" = names(output)[i], "species" = NA, "score" = NA)
        } else {
            output[[i]] <- data.frame("level" = rep(names(output)[i], length(output[[i]])),
                                      "species" = names(output[[i]]),
                                      "score"   = unname(output[[i]]))
        }
    }

    ## Add the relative results
    if(add.relative) {
        make.relative <- function(X) {
            cbind(X, "rel" = ifelse(is.na(X$score), NA, X$score/max(X$score)))
        }
        output <- lapply(output, make.relative)
    }
    rm(disparity)
    return(output)
}
combine.results <- function(res1, res2, sort.results = TRUE) {
    ## Combine the results
    res_out <- rbind(res1[,1:2], res2[, 1:2])
    res_out$elaboration <- c(res1[, 3], rep(NA, nrow(res2)))
    if("rel" %in% colnames(res1)) {
        res_out$rel.elab <- c(res1[, 4], rep(NA, nrow(res2)))
    }
    res_out$innovation <- c(rep(NA, nrow(res1)), res2[, 3])
    if("rel" %in% colnames(res1)) {
        res_out$rel.inno <- c(rep(NA, nrow(res1)), res2[, 4])
    }

    # Remove NA species
    if(any(is_na <- is.na(res_out$species))) {
        if(all(is_na)) {
            return(res_out)
        } else {
            res_out <- res_out[!is_na, , drop = FALSE]
        }
    }

    ## Find any species in commons
    commons <- intersect(res1$species, res2$species)
    if(length(commons) > 0) {
        if(any(is.na(commons))) {
            if(is.na(res1$species)) {
                if(is.na(res2$species)) {
                    ## Both are NA (keep just the first one)
                    res_out <- res_out[-1, , drop = FALSE]
                } else {
                    ## Remove res1
                    res_out <- res_out[-1, , drop = FALSE]
                }
            } else {
                ## Remove res2
                res_out <- res_out[1:length(res1$species), , drop = FALSE]
            }
        } else {
            ## Recursively remove the ones in common
            while(length(commons) > 0) {
                duplicates <- which(res_out$species == commons[1])
                columns <- if("rel" %in% colnames(res1)){c(5,6)} else {4}
                res_out[duplicates[1], columns] <- res_out[duplicates[2], columns]
                res_out <- res_out[-duplicates[2], ]
                commons <- commons[-1]
            }
        }
    }

    if(sort.results) {
        sums <- apply(res_out[, -c(1,2)], 1, sum, na.rm = TRUE)
        rank <- match(sort(sums, decreasing = TRUE), sums)
    } else {
        rank <- 1:nrow(res_out)
    }

    return(res_out[rank,])
}
```

Furthermore, we can look at things species per species to find which species species have the most extreme values (in general, or within their groups).


### Extreme species per super order (species on phylogeny)


```{r, eval = TRUE, echo = FALSE, fig.height = 12, fig.width = 12, eval = TRUE}
super_positions_phylo <- get.distributions(results$super_results_phylo, type = "position")
```
Figure: elaborations distributions per super orders

```{r, eval = TRUE, echo = FALSE, fig.height = 12, fig.width = 12, eval = TRUE}
super_distances_phylo <- get.distributions(results$super_results_phylo, type = "distance")
```
Figure: innovations distributions per super orders

```{r, "printing results in text", echo = FALSE, eval = TRUE}
## Combining the results
super_phylo_table <- do.call(rbind, mapply(combine.results, super_positions_phylo, super_distances_phylo, SIMPLIFY = FALSE))
## Get the top 10%
get.top <- function(data, what, top = 0.9, relative = FALSE) {
    if(any(data[, "level"] == "phylogeny")) {
        data_top <- data[which(data[, "level"] != "phylogeny"), ]
    } else {
        data_top <- data
    }

    ## Get the relative column
    if(relative) {
        what <- switch(what,
                       "elaboration" = "rel.elab",
                       "innovation"  = "rel.inno")
    }
    ## Get the top 10(ish) species
    data_top_10 <- data_top[which(data_top[, what] >= quantile(data_top[, what], prob = top, na.rm = TRUE)), ]
    return(data_top_10[order(data_top_10[, what], decreasing = TRUE), ])
}
top_elabo <- get.top(super_phylo_table, what = "elaboration")
top_innov <- get.top(super_phylo_table, what = "innovation")
```

> And here are the top 10% of the top 1% elaborators and innovators by superorder:

The 10% top elaborators by superorder are: `r paste(paste(top_elabo[, "species"], round(top_elabo[, "elaboration"], 3), sep = ": "), collapse = ", ")`.

The 10% top innovators by superorder are: `r paste(paste(top_innov[, "species"], round(top_innov[, "innovation"], 3), sep = ": "), collapse = ", ")`.

<details>
  <summary>[Click to expand] Table of species extreme values projected onto the phylogenetic VCV.
</summary>

```{r, echo = FALSE}
library(knitr)
rownames(super_phylo_table) <- NULL
kable(super_phylo_table, digits = 3)
```

</details>


### Extreme species per order (species on phylogeny)

```{r, eval = TRUE, echo = FALSE, fig.height = 12, fig.width = 12, eval = TRUE}
order_positions_phylo <- get.distributions(results$order_results_phylo, type = "position", exclude.phylo = TRUE)
```
Figure: elaborations distributions per order

```{r, eval = TRUE, echo = FALSE, fig.height = 12, fig.width = 12, eval = TRUE}
order_distances_phylo <- get.distributions(results$order_results_phylo, type = "distance", exclude.phylo = TRUE)
```
Figure: innovations distributions per order

```{r, echo = FALSE}
order_phylo_table <- do.call(rbind, mapply(combine.results, order_positions_phylo, order_distances_phylo, SIMPLIFY = FALSE))
top_elabo <- get.top(order_phylo_table, what = "elaboration")
top_innov <- get.top(order_phylo_table, what = "innovation")
```

> And here are the top 10% of the top 1% elaborators and innovators by order:
The 10% top ellaborators by order are: `r paste(paste(top_elabo[, "species"], round(top_elabo[, "elaboration"], 3), sep = ": "), collapse = ", ")`.
The 10% top innovators by order are: `r paste(paste(top_innov[, "species"], round(top_innov[, "innovation"], 3), sep = ": "), collapse = ", ")`.


<details>
  <summary>[Click to expand] Table of species extreme values projected onto their own group's VCV.
</summary>

```{r, echo = FALSE}
## Combining the results
rownames(order_phylo_table) <- NULL
kable(order_phylo_table, digits = 3)
```
</details>



### Extreme species per super order (species on group)

```{r, eval = TRUE, echo = FALSE, fig.height = 12, fig.width = 12, eval = TRUE}
super_positions_within <- get.distributions(results$super_results_within, type = "position", exclude.phylo = TRUE,  add.relative = TRUE)
```
Figure: elaborations distributions within super orders

```{r, eval = TRUE, echo = FALSE, fig.height = 12, fig.width = 12, eval = TRUE}
super_distances_within <- get.distributions(results$super_results_within, type = "distance", exclude.phylo = TRUE, add.relative = TRUE)
```
Figure: innovations distributions within super orders


```{r, echo = FALSE}
super_phylo_table_within <- do.call(rbind, mapply(combine.results, super_positions_within, super_distances_within, SIMPLIFY = FALSE))
top_elabo <- get.top(super_phylo_table_within, what = "elaboration", relative = TRUE)
top_innov <- get.top(super_phylo_table_within, what = "innovation", relative = TRUE)
```

> And here are the top 10% of the top 1% elaborators and innovators by superorder relative to each superorder (i.e. the best one(s) in each order):
```{r, echo = FALSE}
combined <- rbind(top_elabo, top_innov)
rownames(combined) <- NULL  
kable(combined, digits = 3)
```

<details>
  <summary>[Click to expand] Table of species extreme values projected onto their own group's VCV.
</summary>

```{r, echo = FALSE}
## Combining the results
rownames(super_phylo_table_within) <- NULL
kable(super_phylo_table_within, digits = 3)
```

</details>


### Extreme species per order (species on group)


```{r, eval = TRUE, echo = FALSE, fig.height = 12, fig.width = 12, eval = TRUE}
order_positions_within <- get.distributions(results$order_results_within, type = "position", exclude.phylo = TRUE, add.relative = TRUE)
```
Figure: elaborations distributions within orders

```{r, eval = TRUE, echo = FALSE, fig.height = 12, fig.width = 12, eval = TRUE}
order_distances_within <- get.distributions(results$order_results_within, type = "distance", exclude.phylo = TRUE, add.relative = TRUE)
```
Figure: innovations distributions within orders



```{r, echo = FALSE}
order_phylo_table_within <- do.call(rbind, mapply(combine.results, order_positions_within, order_distances_within, SIMPLIFY = FALSE))
top_elabo <- get.top(order_phylo_table_within, what = "elaboration", relative = TRUE)
top_innov <- get.top(order_phylo_table_within, what = "innovation", relative = TRUE)
```

> And here are the top 10% of the top 1% elaborators and innovators by order relative to each order (i.e. the best one(s) in each order):
```{r, echo = FALSE}
combined <- rbind(top_elabo, top_innov)
rownames(combined) <- NULL  
kable(combined, digits = 3)
```


<details>
  <summary>[Click to expand] Table of species extreme values projected onto their own group's VCV.
</summary>

```{r, echo = FALSE}
## Combining the results
rownames(order_phylo_table_within) <- NULL
kable(order_phylo_table_within, digits = 3)
```
</details>



## Correlations between elaboration and innovation?

```{r, echo = FALSE}
## Calculating all the correlations
get.correlations <- function(res, cent.tend = median, exclude.phylo = FALSE) {

    ## Remove the phylo one (if needed)
    if(exclude.phylo) {
        select_pos <- names(size.subsets(res$position))
        select_dis <- names(size.subsets(res$distance))
        select_pos <- select_pos[-which(select_pos %in% "phylogeny")]
        select_dis <- select_dis[-which(select_dis %in% "phylogeny")]
        res$position <- get.subsets(res$position, subsets = select_pos)
        res$distance <- get.subsets(res$distance, subsets = select_dis)
    }

    ## Extracting all the results
    disparity_pos <- lapply(res$position$disparity, function(X, type) return(X$elements))
    disparity_dis <- lapply(res$distance$disparity, function(X, type) return(X$elements))

    ## Measure the central tendencies
    centrals_pos <- lapply(disparity_pos, function(X, fun) apply(X, 1, fun), fun = cent.tend)
    centrals_dis <- lapply(disparity_dis, function(X, fun) apply(X, 1, fun), fun = cent.tend)
    
    ## Number of groups
    n_groups <- length(centrals_pos)

    ## Prepare the results
    prep.cor.results <- function(pos, dis, name) {
        ## Run the correlation test
        cor_test <- cor.test(pos, dis)
        ## Prepare the plot title
        plot_main <- paste0(name, ": ", unname(round(cor_test$estimate, 3)), " (p=", unname(round(cor_test$p.value, 3)), ")")
        ## Return the plotting parameters
        return(list(x = pos, y = dis, main = plot_main))
    }

    return(mapply(prep.cor.results, centrals_pos, centrals_dis, as.list(names(centrals_pos)), SIMPLIFY = FALSE))
}
    
## Plotting one correlation 
plot.correlations <- function(cor.results, col.sub, col.fun = rainbow, legend.pos = "topleft", pt.cex = 0.5, legend.cex = 0.5, tree, full.tree = FALSE, ...) {
    dots <- list(...)

    if(missing(col.sub)) {
        col.sub <- NULL
    }

    ## Subbing the colours
    if(!is.null(col.sub)) {
        ## Reset the levels
        col_sub <- as.factor(as.character(col.sub))
        ## Make the empty level grey
        if(any(levels(col_sub) == "")) {
            col_avail <- c("grey", col.fun(length(levels(col_sub))-1))
        } else {
            col_avail <- col.fun(length(levels(col_sub)))
        }
        ## Create the colour vector
        col_vector <- col_avail[as.numeric(col_sub)]

    } else {
        if(is.null(dots$col)) {
            col_vector <- "black"
        } else {
            col_vector <- dots$col
        }
    }

    if(!missing(tree)) {
        op <- par(mfrow = c(1,2))
        #c(bottom, left, top, right); c(5, 4, 4, 2) + 0.1
        par(mar = c(5, 4, 4, 0)+0.1)   
    }

    ## Plotting the results
    plot(cor.results$x, cor.results$y, pch = 19, xlab = "elaboration", ylab = "innovation", main = cor.results$main, cex = pt.cex, col = col_vector)

    if(!is.null(col.sub)) {
        ## Adding the legend
        legend(x = legend.pos, legend = levels(col_sub), pch = 19, cex = legend.cex, col = col_avail)
    }

    if(!missing(tree)) {
        par(mar = c(5, 0, 4, 2) + 0.1)

        ## Recycle the colour vector
        named_col_vector <- col_vector
        names(named_col_vector) <- names(cor.results$x)

        ## Reduce the tree
        if(!full.tree) {
            tree <- drop.tip(tree, tip = tree$tip.label[which(!(tree$tip.label %in% names(named_col_vector)))])
        }

        ## Matching edges and colours
        match.edge.colours <- function(tree, named_col_vector, background = "grey") {
            ## Get the background colour
            edge_cols <- rep(background, Nedge(tree))
            ## Get the clades
            clades <- unique(named_col_vector)
            ## Ignore the greys
            if(any(which_grey <- clades == "grey")) {
                clades <- clades[!which_grey]
            }
            ## Find the edges for each clade
            for(clade in 1:length(clades)) {
                ## Get the tips for the clade
                tips <- which(named_col_vector == clades[clade])
                ## Get the MRCA node
                mrca_node <- getMRCA(tree, tips)
                # stop_edge <- which(tree$edge[, 2] %in% mrca_node)

                ## Handle non-monophyletic groups
                clade_tree <- extract.clade(tree, node = mrca_node)
                if(Ntip(clade_tree) > length(tips)) {
                    clade_tree <- drop.tip(clade_tree, tip = clade_tree$tip.label[!(clade_tree$tip.label %in% names(tips))])
                }
                n_edges_target <- Nedge(clade_tree)

                ## Get the tips ID
                tip_ids <- which(tree$tip.label %in% names(tips))
                ## Get the vector of edges
                edges <- integer()
                ## Get the first nodes (and edges)
                new_edges <- which(tree$edge[, 2] %in% tip_ids)
                edges <- unique(c(edges, new_edges))
                nodes <- tree$edge[new_edges, 1]

                # plot(tree, show.tip.label = FALSE)
                # test.col <- c(replicate(10, c("red", "blue", "orange", "green", "pink", "yellow")))
                # edgelabels(".", cex = 0.5, new_edges, bg = test.col[1]) ; test.col <- test.col[-1]

                ## Recursively loop through each node up until the last edge
                # while(!(stop_edge %in% edges)) {
                while(length(edges) <= n_edges_target) {
                    ## Get the node edges
                    new_edges <- which(tree$edge[, 2] %in% nodes)

                    # edgelabels(".", cex = 0.5, new_edges, bg = test.col[1]) ; test.col <- test.col[-1]

                    edges <- unique(c(edges, new_edges))
                    ## Update the nodes
                    nodes <- tree$edge[new_edges, 1]
                }

                # ## Do the last recursion
                # new_edges <- which(tree$edge[, 2] %in% nodes)
                # edges <- unique(c(edges, new_edges))

                # edgelabels(".", cex = 0.5, new_edges, bg = test.col[1]) ; test.col <- test.col[-1]

                ## Colour these edges
                edge_cols[edges] <- clades[clade]
            }
            return(edge_cols)
        }
        ## Match the colour to the correct edge
        edge_cols <- match.edge.colours(tree, named_col_vector)

        ## Add the tree
        plot(tree, show.tip.label = FALSE, edge.color = edge_cols)
    }

    return(invisible())
}
```

### Correlations per super order (species on phylogeny)

```{r, eval = TRUE, echo = FALSE, fig.height = 6, fig.width = 12, eval = TRUE}
## Getting the subsets for the colouring
col_subs <- c(split(shapespace$level2, f = shapespace$level1)[-1], "phylogeny" = list(shapespace$level1))
## Calculate the correlations
super_phylo_cor <- get.correlations(results$super_results_phylo)
## Set the vector of legend positions
legends_pos <- c("topleft", "topright", "topright", "topright", "topleft", "topright", "topleft", "topright", "topright")
for(i in 1:length(super_phylo_cor)) {
    plot.correlations(super_phylo_cor[[i]], col.sub = col_subs[[i]], legend.pos = legends_pos[i], tree = tree)
}
```

### Correlations within super orders (species on group)


```{r, eval = TRUE, echo = FALSE, fig.height = 6, fig.width = 12, eval = TRUE}
## Getting the subsets for the colouring
col_subs <- split(shapespace$level2, f = shapespace$level1)[-1]

## Calculate the correlations
super_within_cor <- get.correlations(results$super_results_within, exclude.phylo = TRUE)
## Set the vector of legend positions
legends_pos <- c("topleft", "topright", "topright", "topright", "topleft", "topright", "topleft", "topright", "topright")
for(i in 1:length(super_within_cor)) {
    plot.correlations(super_within_cor[[i]], col.sub = col_subs[[i]], legend.pos = legends_pos[i], tree = tree)
}
```

### Correlations per order (species on phylogeny)

```{r, eval = TRUE, echo = FALSE, fig.height = 6, fig.width = 6, eval = FALSE}
## Loading the sub-order levels
load(file = "../Data/Processed/shapespace_superorder_lvl_order_suborder.rda")
## Select the data
shapespaces <- lapply(shapespace_superorder_lvl_order_suborder, function(X) X$space)
## Create a level 3
order_space <- do.call(rbind, shapespaces)

## Calculate the correlations
order_phylo_cor <- get.correlations(results$order_results_phylo, exclude.phylo = TRUE)

## Getting the subsets for the colouring
split_tmp <- split(order_space$level2, f = order_space$level1)[-1] ## "Charadriiformes" "Galliformes" not included?
col_subs <- replicate(length(order_phylo_cor), NULL)
col_subs[-c(6,12)] <- split_tmp[match(sort(names(split_tmp)), names(split_tmp))]

## Set the vector of legend positions
for(i in 1:length(order_phylo_cor)) {
    plot.correlations(order_phylo_cor[[i]], col.sub = col_subs[[i]])
}
```

### Correlations within orders (species on group)


```{r, eval = TRUE, echo = FALSE, fig.height = 6, fig.width = 6, eval = FALSE}
## Calculate the correlations
order_within_cor <- get.correlations(results$order_results_within, exclude.phylo = TRUE)

## Getting the subsets for the colouring
split_tmp <- split(order_space$level2, f = order_space$level1)[-1] ## "Charadriiformes" "Galliformes" not included?
col_subs <- replicate(length(order_within_cor), NULL)
col_subs[-c(6,12)] <- split_tmp[match(sort(names(split_tmp)), names(split_tmp))]

## Set the vector of legend positions
for(i in 1:length(order_within_cor)) {
    plot.correlations(order_within_cor[[i]], col.sub = col_subs[[i]])
}
```






































































