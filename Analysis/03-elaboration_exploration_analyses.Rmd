---
title: "Bird beak's elaboration and exploration"
author: "Thomas Guillerme"
date: "`r Sys.Date()`"
bibliography: references.bib
output:
  html_document:
    fig_width: 8
    fig_height: 8
---


All the custom code and custom functions called in this document can be downloaded and installed in `R` as the standalone working package `beer` (Beak Elaboration and Exploration in R).
Although `beer` is intentionally designed to be portable and shareable, we advise workers to use it with moderation and tailor its consumption to their specific research needs.
Some analyses in `beer` do take some time to run so we advise users not to operate heavy machinery while using it.
Don't use it while driving.
The following code snippets are used to illustrate the implementation of the functions.
See <!-- §§§run_replicates_script --> for running the actual analyses.

# Elaboration and exploration analyses

```{r, eval = TRUE, echo = FALSE}
library(beer)
## Loading the MCMCglmm
load("../Data/processed/combined_results.rda")
## Loading the tree and data
data(demo_data)
data(demo_tree)
## Setting the colour vector
colour_vector <- c("orange", "blue", "darkgreen")
```

## Extracting the variance-covariance matrices from the MCMCglmm mini-chains

To analyse the exploration and elaboration aspects of both clades and tips, we first selected 1000 random covariance matrices from the combined MCMCglmm posterior variance-covariance matrices.

```{r, eval = TRUE}
set.seed(42)
## Selecting 1000 random covariance matrices from the MCMCglmm
covar_matrices <- get.covar(combined_results, n = 1000)[1:4]
```

We use these covariance matrices as the basis of the phylogenetic main axes of variation.
These axes correspond to the main axes of variation in the $N_DIMENSIONS$ trait space at different phylogenetic levels: 

 * The whole bird phylogeny level ("phylogeny level");
 * And the named node levels ("clade levels").

These major axes were calculated as the longest distance within the 95% confidence interval hyper-ellipse from the variance-covariance matrix (i.e. the major axes of the 95% CI ellipse of matrix). <!-- % NC: A small figure here would help -->

```{r, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 5}
set.seed(42)
## Space plot
cor_matrix <- matrix(cbind(1, 0.8, 0.8, 1), nrow = 2)
space <- space.maker(50, 2, rnorm, cor.matrix = cor_matrix)
lim <- c(floor(range(space)[1]), ceiling(range(space)[2]))
plot(space, pch = 19, xlab = "Trait 1", ylab = "Trait 2", xlim = lim, ylim = lim)

## Plotting the ellipse
lines(ellipse::ellipse(cor_matrix), col = "blue", lwd = 3)
## Plotting the major axis
lines(get.axes(list(list(list(VCV = cor_matrix, Sol = c(0,0)))))[[1]][[1]], lwd = 3, col = "orange")
```

Figure: the main axis of variation (in orange) of the 95% CI ellipse of the variance-covariance matrix (in blue) of 20 elements in 2 dimensions (in black).


In practice, the coordinates of these axes end points were calculated directly from the cross product between the 95% unit hypersphere scaled by the variance-covariance matrix's squared eigenvalues and the variance-covariance matrix's eigenvectors.

## Major axes calculation
<!-- % NC: Mathematically seems sound, but I'm no expert. But very hard to parse for anyone who hasn't been looking at this in detail. Think fo the poor palaeontologists!
 -->
For $O_{n}$, the unit hypersphere matrix of _n_ dimensions and a radius composed of the two identity matrices $I_{n}$ and $-I_{n}$ so that: 

\begin{equation}
O_{n} = 
    \begin{pmatrix}
        1 & 0 & \cdots & 0 \\
        0 & 1 & \cdots & 0 \\
        \vdots  & \vdots  & \ddots & \vdots  \\
        0 & 0 & \cdots & 1 \\
        -1 & 0 & \cdots & 0 \\
        0 & -1 & \cdots & 0 \\
        \vdots  & \vdots  & \ddots & \vdots  \\
        0 & 0 & \cdots & -1 \\
    \end{pmatrix}
\end{equation}

(in other words $O_{n}$ is the matrix representing each edge point of the unit hypersphere of $n$ dimensions and of radius $1$);

And $O'_{n}$ is the scaled matrix hypersphere to the 95\% confidence interval size using the $\chi^2$ distribution:

\begin{equation}
    O'_{n} = O_{n} \sqrt{\chi^2(0.95)}
\end{equation}

For the variance-covariance matrix $VCV_{n}$ of $n$ dimensions

\begin{equation}
VCV_{n} = 
    \begin{pmatrix}
        \sigma(a) & \sigma(a,b) & \cdots & \sigma(a,n) \\
        \sigma(a,b) & \sigma(b) & \cdots & \sigma(b,n) \\
        \vdots  & \vdots  & \ddots & \vdots  \\
        \sigma(n,a) & \sigma(n,b) & \cdots & \sigma(n) \\
    \end{pmatrix}
\end{equation}

and the eigenvectors **v** and the eigenvalues $\lambda$ satisfying the following eigen decomposition:

\begin{equation}
    VCV_{n} \bold{v} = \lambda \bold{v}
\end{equation}

We can get $M_{n}$ matrix containing all the edge coordinates of the 0.95 CI hypersphere from $VCV_{n}$ using the transposition of the cross product between the eigenvectors **v** and the product of the scale 0.95 CI unit sphere $O'_{n}$ and the eigenvalues $\lambda$:

\begin{equation}
    M_{n} = [(O'_{n}\sqrt{\lambda}) \times \bold{v}]^{\text{T}}
\end{equation}

Where $M_{1,n}$ is the major axis of the 0.95 CI hyper-ellipse fitting the variance-covariance matrix, $M_{2,n}$ the second axis (minor axis in 2D), etc. etc.

Finally, we centred the matrix $M_{1,m}$ on the centroid of each clade.


> The detailed procedure was adapted from [李哲源's post on Stack Overflow](https://stackoverflow.com/questions/40300217/obtain-vertices-of-the-ellipse-on-an-ellipse-covariance-plot-created-by-care/40316331#40316331) and implemented in `beer::get.axes` ([specific procedure on lines 40-73](https://github.com/TGuillerme/elaboration_exploration_bird_beaks/blob/master/beer/R/get.axes.R)).

```{r}
## Get the centre of each clade
group_centres <- list(
    "gulls"      = colMeans(demo_data[demo_data$clade == "gulls", c(1:4)]),
    "plovers"    = colMeans(demo_data[demo_data$clade == "plovers", c(1:4)]),
    "sandpipers" = colMeans(demo_data[demo_data$clade == "sandpipers", c(1:4)]),
    "phylogeny"  = colMeans(demo_data[, c(1:4)]))

## Calculating the major axes
major_axes <- get.axes(covar_matrices, centre = group_centres)
```

One can visualise these ellipses and major axes in 2D using the `beer::plot.axes` and `beer::plot.ellipses` functions (based on @ellipse):

```{r}
set.seed(51)
## Sub-selecting 5 random VCV matrices for readibility
sub_sample_matrices <- get.covar(combined_results, 5)[1:4]
sub_sample_major_axes <- get.axes(sub_sample_matrices, centre = "intercept")

## Plotting the ellipses
plot.ellipses(sub_sample_matrices, col = c("grey",colour_vector),
              add = FALSE, transparent.scale = 0.5)
plot.axes(sub_sample_major_axes, col = c("grey",colour_vector),
              add = TRUE, transparent.scale = 0.7)
legend("topleft",
       legend = c("phylogeny", levels(demo_data$clade)),
       col = c("grey", colour_vector), lty = 1)
```

We can also visualise all the major axes in relation to the elements in the space.

```{r, fig.height = 10, fig.width = 10}
## Plotting it
plot.space(demo_data,
           col = colour_vector,
           levels = demo_data$clade,
           xlab = "PC1 (90.5%)",
           ylab = "PC1 (6.86%)",
           xlim = c(-2, 2),
           ylim = c(-1, 1))
points(do.call(rbind,group_centres)[,c(1,2)],
       pch = 13, col = c(colour_vector, "grey"))
plot.axes(major_axes["animal"], col = "grey",
          add = TRUE, transparent.scale = 0.01,
          centre = 0)
plot.axes(major_axes["animal:clade1"], col = colour_vector[1],
          add = TRUE, transparent.scale = 0.01,
          centre = colMeans(demo_data[demo_data$clade == "gulls", c(1,2)]))
plot.axes(major_axes["animal:clade2"], col = colour_vector[2],
          add = TRUE, transparent.scale = 0.01,
          centre = colMeans(demo_data[demo_data$clade == "plovers", c(1,2)]))
plot.axes(major_axes["animal:clade3"], col = colour_vector[3],
          add = TRUE, transparent.scale = 0.01,
          centre = colMeans(demo_data[demo_data$clade == "sandpipers", c(1,2)]))
legend("topleft",
       legend = c("phylogeny", levels(demo_data$clade)),
       col = c("grey", colour_vector),
       lty = c(1,1,1,1),
       pch = c(NA, 19, 19, 19))
```


We can then compare these axes either with each other or relative to the tip positions in the trait space using elaboration and exploration scores as described below.

## Elaboration and exploration scores calculations

From the major axes calculated above, we can use linear algebra in $n$ dimensions to estimate exploration and elaboration scores for clades or tips of the tree.
These scores are a direct interpretation of @endler2005's elaboration and innovation (here exploration) patterns (Fig 1. in @endler2005):
Given a major axis of evolutionary "trajectory" (in the sense of evolutionary trend, not an evolutionary direction), we can calculate the elaboration score as the projection value of any vector defined by a clade or a tip on the major axis and the exploration (or "innovation" in @endler2005) as that vector's rejection.

```{r, echo = FALSE, eval = TRUE}
source("../Functions/test.rotation.R")
```

Figure: in a space with five elements: A, B, C, D, E (in grey); where D and E represent the major axes (e.g. the major phylogenetic effect axes from the MCMCglmm), we can rotate and rescale each element so that D and E become the unit vector of length 1 (the black letters D and E) and get the exploration and elaboration scores for either the elements (e.g. element A's projection in blue and its rejection in orange) or from any other axes (e.g. the major phylogenetic effect axes from the MCMCglmm for a specific clade).

#### Measuring projection and rejection

For any vectors $\vec{a}$ and $\vec{b}$, defined either as one set or a pair of sets of coordinates in $n$ dimensions:

\begin{equation}
    \vec{a} = 
    \begin{bmatrix}
    x \\
    y \\
    \cdots \\
    n \\
    \end{bmatrix}
\end{equation}

\begin{equation}
    \vec{a} = 
    \begin{bmatrix}
    x_{1} & x_{2} \\
    y_{1} & y_{2} \\
    \cdots & \cdots \\
    n_{1} & n_{2} \\
    \end{bmatrix}
\end{equation}

We can calculate $\vec{a_{1}}$, the orthogonal projection of $\vec{a}$ onto $\vec{b}$ using:

\begin{equation}
    \vec{a_{1}} = \frac{\vec{a} \cdot \vec{b}}{\|\vec{b}\|}
\end{equation}

With $\|\vec{b}\| = \sqrt{\vec{b} \cdot \vec{b}}$ being the norm of $\vec{b}$.
And $\vec{a_{2}}$, the rejection of $\vec{a}$ onto $\vec{b}$:

\begin{equation}
    \vec{a_{2}} = \vec{a} - \vec{a_{1}}
\end{equation}


#### Generalisation of projection onto any vector in a set space

Using this, we can calculate the projection and rejection for any element within a trait space $TS_{m,n}$:

\begin{equation}
    TS_{m,n} = 
    \begin{bmatrix}
    x_{1} & x_{2} & \cdots & x_{m} \\
    y_{1} & y_{2} & \cdots & y_{m} \\
    \vdots  & \vdots  & \ddots & \vdots \\
    n_{1} & n_{2} & \cdots & n_{m} \\
    \end{bmatrix}
\end{equation}

And any base vector $\vec{B}$ defined as:

\begin{equation}
    B = 
    \begin{bmatrix}
    x_{1} & x_{2}\\
    y_{1} & y_{2}\\
    \vdots  & \vdots  \\
    n_{1} & n_{2} \\
    \end{bmatrix}
\end{equation}

By using the linear transformation $f_{\vec{B}}$ of the trait space $TS$ moving $\vec{B}$ onto $TS$'s first axes unit vector $\vec{\hat{\imath}}$:

\begin{equation}
    f_{\vec{B}}(TS) = \left( \frac{TS - [Bx_{1}, By_{1}, \cdots, Bn_{1}]^{\text{T}}}{\|\vec{B}\|} \right) \cdot R_{\vec{B}}
\end{equation}

With R_{\vec{B}} being the rotation matrix of the vector $\vec{B}$ onto $\vec{\hat{\imath}}$:

\begin{equation}
R_{\vec{B}} = I_{\vec{B}} - \vec{B}\vec{B}^\text{T} - \vec{\hat{\imath}}\vec{\hat{\imath}}^\text{T} + [\vec{B} \vec{\hat{\imath}}]     \begin{bmatrix}
        cos(\theta) & -sin(\theta)\\
        sin(\theta) & cos(\theta)\\
    \end{bmatrix} [\vec{B} \vec{\hat{\imath}}]^\text{T}
\end{equation}

Where $\theta$ is:

\begin{equation}
    \theta = acos \left(\frac{\vec{B} \cdot \vec{\hat{\imath}}}{\|\vec{B}\| \cdot \|\vec{\hat{\imath}}\|} \right)
\end{equation}

Or $\theta = acos (B_x)$ since both $\|\vec{B}\|$ and $\|\vec{\hat{\imath}}\|$ are equal to 1 and $\|\vec{\hat{\imath}}\|$ is the unit vector on the first axis.

#### Algorithm for calculating the projection/rejection of any element in a defined space

In practice we followed [this procedure](https://math.stackexchange.com/questions/598750/finding-the-rotation-matrix-in-n-dimensions) and applied a modification of [this implementation](https://stackoverflow.com/questions/42520301/find-rotation-matrix-of-one-vector-to-another-using-r/42542385#42542385) (see @aguilera2004 for the formal generalisation of this algorithm) using the following algorithm implemented in `dispRity::projections` (@disprity):

 1. In the trait space, define $\vec{B}$ as the base vector (typically $\vec{B}$ is defined as the pair of coordinates set from the major axis described above).
 2. Centre the trait space on the origin of $\vec{B}$ so that the first set of coordinates of $\vec{B}$ are 0.
 3. Scale the trait space to the norm of $\vec{B}$ so that the norm of $\vec{B}$ is now 1.
 4. Rotate the trait space using the rotation matrix $R_{\vec{B}}$ to satisfy the linear transformation $\vec{B} \arrow \vec{\hat{\imath}}$ (with $\vec{\hat{\imath}}$ being the first unit vector of the trait space - typically the x axes unit vector). 
 5. Project/reject every element in the trait on $\vec{B}$ (that is now $\vec{\hat{\imath}}$). In practice, the first coordinate (x) of each element is now its projection onto $\vec{B}$.

Following the ways to: <!-- %NC: Not sure what you mean here -->
 1. estimate the variance-covariance matrices of the phylogenetic effects in trait space (02-MCMCglmm_mini_chains.Rmd);
 2. extracting the major axes of variation of these VCV matrices for the different levels in the phylogeny;
 3. and calculating the elaboration and exploration scores for elements in the trait space based on these major axes.

We can measure these scores for each clade and each species separately.

## Elaboration and exploration by clade

To run the analyses for each clade we compared the major axes for each clade to the major axes for the overall phylogenetic effect (e.g. plovers' VCV vs. all birds' VCV, etc.).

To do so, for a randomly selected posterior variance-covariance matrix we defined $\vec{a}$ as the major axes for the clade of interest and projected it onto $\vec{B}$ as the major overall phylogenetic effect (see above).
For each pair of $\vec{a}$ and $\vec{B}$, we translated the origin of $\vec{a}$ onto the origin of $\vec{B}$ and measured the projection (elaboration), rejection (exploration) and angle (degree of exploration).

```{r}
## Get all the angles and stuff
group_results <- analyses.group(major_axes, base = "animal")
names(group_results) <- levels(demo_data$clade)
```

The results are reported as boxplots for each group indicating which group explores/elaborates more (and to which degree - angle) relatively to each other.

```{r}
## Plot the blob wise metrics
plot.analyses.group(group_results, col = colour_vector)
```

## Elaboration and exploration by species

Similarly to the analyses described above, we ran the analyses for each species but here we directly compared each species position in the space to the same vector $\vec{B}$ described above and reported the results for each groups.

```{r}
## Global analyses
tip_results_global <- analyses.tip(data = demo_data[, c(1:4)],
                                   axes = major_axes$animal)
```

And here are the values plotted by group:

```{r}
## Plot results
plot.analyses.tip(tip_results_global,
                  col = colour_vector,
                  group = split(rownames(demo_data), f = demo_data$clade),
                  main = "Tips vs. whole phylogeny")
```

Note that here only the tip positions are projected on the global phylogenetic axes.

Finally, we also looked at the exploration elaboration profiles within each clade, by replacing the projection of the elements onto $\vec{B}$ for each clade to the projection onto their respective clade major axes $\vec{a}$.

```{r}
## Results within groups
tip_results_within <- analyses.tip(
                    data = demo_data[, c(1:4)],
                    axes = major_axes[-length(major_axes)],
                    group = split(rownames(demo_data), f = demo_data$clade))
```

```{r}
## Plot results
plot.analyses.tip(tip_results_within,
                  col = colour_vector,
                  group = split(rownames(demo_data), f = demo_data$clade),
                  main = "Tips vs. clade")
```

But this is probably best to look at in a species by species fashion:

TODO



 
## References
