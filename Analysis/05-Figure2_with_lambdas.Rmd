---
title: "Bird beak's elaboration and innovation"
author: "Gavin Thomas & Thomas Guillerme"
date: "`r Sys.Date()`"
bibliography: references.bib
output:
  html_document:
    fig_width: 8
    fig_height: 8
---


## Calculate the lambdas for the whole tree and nested clades

```{r, echo = FALSE}
## Loading the clade info
load("../Data/Processed/group_species_names.rda")

## Loading the plotting data
load("../Data/Processed/ploting_data.rda")

## Function for measuring Pagel's lambda from a sub-tree
#' @param species a vector of species names to extract from tree
#' @param variable the variable (a named vector with the correct species names)
#' @param tree the full tree
#' @param method the method to be passed to motmot::transformPhylo.ML (default is "lambda")
#' @param ... any other arguments to be passed to motmot::transformPhylo.ML
get.p.lambda <- function(species, variable, tree, method = "lambda", ...) {
    ## Selected species
    to_keep <- tree$tip.label %in% species

    ## Trim the tree
    sub_tree <- drop.tip(tree, tip = tree$tip.label[!to_keep])
    
    ## Trim the variable
    sub_var <- variable[species]

    ## Measure lambda
    return(motmot::transformPhylo.ML(phy = sub_tree, y = matrix(sub_var, ncol = 1, dimnames = list(names(sub_var))), model = method, ...))
}


## Get the lambdas for all levels for the elaborations
overall_lambda_elaboration <- get.p.lambda(species = ploting_data$consensus_tree$tip.label, variable = ploting_data$median_elaborations, tree = ploting_data$consensus_tree, modelCIs = FALSE)
all_lambdas_elaboration <- lapply(group_species_names, lapply, function(x, tree, variable, ...) {cat(".") ; get.p.lambda(names(x), variable, tree, ...)},
                                  tree = ploting_data$consensus_tree,
                                  variable = ploting_data$median_elaborations,
                                  modelCIs = FALSE)
overall_lambda_innovation <- get.p.lambda(species = ploting_data$consensus_tree$tip.label, variable = ploting_data$median_innovations, tree = ploting_data$consensus_tree, modelCIs = FALSE)
all_lambdas_innovation <- lapply(group_species_names, lapply, function(x, tree, variable, ...) {cat(".") ; get.p.lambda(names(x), variable, tree, ...)},
                                  tree = ploting_data$consensus_tree,
                                  variable = ploting_data$median_innovations,
                                  modelCIs = FALSE)
## Make into a table
lambda_elaboration <- list(overall_lambda_elaboration$Lambda, lapply(all_lambdas_elaboration, lapply, function(X) return(X$Lambda)))
lambda_innovation <- list(overall_lambda_innovation$Lambda, lapply(all_lambdas_innovation, lapply, function(X) return(X$Lambda)))
lambda_table <- cbind(unlist(lambda_elaboration), unlist(lambda_innovation))
lambda_table <- data.frame(rbind(c("class", "aves"), do.call(rbind, strsplit(rownames(lambda_table), split = "\\."))), lambda_table)
colnames(lambda_table) <- c("level", "name", "elaboration", "innovation")
rownames(lambda_table) <- lambda_table$name
```

```{r}
rownames(lambda_table) <- NULL
## Save the lambda table:
knitr::kable(lambda_table)
```

The problem here is that lambdas are single point estimates on single point estimates (median elaboration/innovation mapped on the consensus tree).
It doesn't give much nuanced information and kind of defeats the `mcmcmcglmmmm` approach!
Here's an approach getting the lambda for each tree.


```{r, echo = FALSE, eval = FALSE}
## Results loading
load(file = "../Data/Processed/shapespace_allbirds_lvl_superorder_order_results_list.rda")
results <- shapespace_allbirds_lvl_superorder_order_results_list
rm(shapespace_allbirds_lvl_superorder_order_results_list)
## Trees loading
load(file = "../Data/Processed/shapespace_allbirds_lvl_superorder_order.rda")
## Select the trees
trees <- shapespace_allbirds_lvl_superorder_order[[1]]$trees_list[sample(1:1000, 400)]
rm(shapespace_allbirds_lvl_superorder_order)

## Extract the relevant bits
species_results <- list(
      "all_birds_global" = lapply(results$super_results_phylo, get.subsets, subsets = "phylogeny"),
      "super_global" = lapply(results$super_results_phylo, get.subsets, subsets = names(size.subsets(results$super_results_phylo[[1]]))[1:8]),
      "super_within" = lapply(results$super_results_within, get.subsets, subsets = names(size.subsets(results$super_results_within[[1]]))[1:8]),
      "order_global" = lapply(results$order_results_phylo, get.subsets, subsets = names(size.subsets(results$order_results_phylo[[1]]))[-28]),
      "order_within" = lapply(results$order_results_within, get.subsets, subsets = names(size.subsets(results$order_results_within[[1]]))[-28])
      )

## Subsample 20 measurements for each
get.subsamples <- function(X, n = 20) {
  return(lapply(get.disparity(X, concatenate = FALSE), function(x, n) return(x[, sample(1:ncol(x), n), drop = FALSE]), n = n))
}
species_results <- lapply(species_results, lapply, get.subsamples)

## Measure lambdas for each groups
get.lambdas <- function(x, trees, verbose = TRUE) {

    if(verbose) {
      cat(paste0("Getting lambda for ", dim(x)[1], " tips:..."))
    }

    ## Get the species
    species <- rownames(x)

    ## Selected species
    to_keep <- trees[[1]]$tip.label %in% species

    ## Trim the tree
    sub_trees <- lapply(trees[sample(1:length(trees), ncol(x))], drop.tip, tip = trees[[1]]$tip.label[!to_keep])
    class(sub_trees) <- "multiPhylo"

    ## Listify the variables
    variables <- apply(x, 2, list)
    
    ## Measure lambda
    mapply.motmot <- function(data, tree) {
      return(motmot::transformPhylo.ML(phy = tree, y = matrix(data[[1]], ncol = 1, dimnames = list(names(data[[1]]))), model = "lambda")$Lambda)
    }
    out <- t(mapply(mapply.motmot, data = variables, tree = sub_trees))
    colnames(out) <- c("MLLambda", "LowerCI", "UpperCI")

    if(verbose) {
      cat(paste0("Done.\n"))
    }

    ## Measure lambda
    return(out)
}

## Get the distributions of lambdas (20 per groups)
lambda_distributions <- lapply(species_results, lapply, lapply, get.lambdas, trees = trees)
save(lambda_distributions, file = "../Data/Processed/lambda_distributions.rda")
```

```{r, echo = FALSE, eval = TRUE, fig.height = 18, fig.width = 12}
## Summarising the lambdas
load(file = "../Data/Processed/lambda_distributions.rda")

## Function for plotting the lambda lines
plot.one.lambda <- function(loc = 1, one_lambda, col = "black") {
  ## Add the lambda range
  lines(y = rep(loc, 2), x = range(one_lambda), lwd = 1, col = col, lty = 3)
  ## Add the median range
  lines(y = rep(loc, 2), x = c(median(one_lambda[,"LowerCI"]), median(one_lambda[, "UpperCI"])), lty = 2, lwd = 1.5, col = col)
  ## Add the mean range
  lines(y = rep(loc, 2), x = range(one_lambda[, "MLLambda"]), lty = 1, lwd = 4, col = col)
  ## Add the median point estimate
  points(y = loc, x = median(one_lambda[, "MLLambda"]), pch = 19, col = col)
}

## List of elements to plot
y_locs <- 1:length(c("Aves", names(lambda_distributions$super_global[[1]]), names(lambda_distributions$order_global[[1]])))
names(y_locs) <- c("Aves", names(lambda_distributions$super_global[[1]]), names(lambda_distributions$order_global[[1]]))

## List of colours
## Colour palette is from figure 4
load("../Data/Processed/tip_colours_orders.rda")
load("../Data/Processed/tip_colours_super_orders.rda")
## Set the background colours
col <- rep("grey", length(y_locs))
names(col) <- names(y_locs)
col[names(tip_colours_super_orders)] <- tip_colours_super_orders
col[names(tip_colours_orders)] <- tip_colours_orders

## Selecting the right data and group ID
get.data.ID <- function(one_group, type = "global") {
  if(one_group == 1) {
    ## All birds
    return("all_birds_global")
  }
  if(one_group < 10) {
    ## Super order level
    if(type == "global") {
        return("super_global")
    } else {
        return("super_within")
    }
  }
  ## Order level
  if(type == "global") {
      return("order_global")
  } else {
      return("order_within")
  }  
}
get.group.ID <- function(one_group) {
  ## All birds
  if(one_group == 1) {
    return(1)
  }
  ## Super orders
  if(one_group < 10) {
    return(one_group - 1)
  }
  ## orders
  return(one_group - 9)
}

par(mfrow = c(1,2))
## Elaboration results
par(mar = c(4, 8, 4, 0) + 0.1) # c(bottom, left, top, right) 
plot(NULL, xlim = c(0,1), xlab = "Pagel's Lambda", ylim = rev(range(min(y_locs)-0.5, max(y_locs))), main = "Elaboration", ylab = "", yaxt = "n")
axis(2, labels = names(y_locs), at = y_locs-0.25, las = 2)

## Super orders
for(one_group in y_locs) {
    ## Adding the lambda distributions global
    abline(h = y_locs[one_group]+0.25, col = "grey", lwd = 0.5)
    plot_data <- lambda_distributions[[get.data.ID(one_group, type = "global")]][["position"]][[get.group.ID(one_group)]]
    plot.one.lambda(loc = y_locs[one_group]-0.5, plot_data, col = col[[one_group]])
    ## Adding the position within
      plot_data <- lambda_distributions[[get.data.ID(one_group, type = "within")]][["position"]][[get.group.ID(one_group)]]
    plot.one.lambda(loc = y_locs[one_group], plot_data, col = adjustcolor(col[[one_group]], alpha = 0.5))
}

## Innovation results
par(mar = c(4, 0, 4, 8) + 0.1)
plot(NULL, xlim = c(0,1), xlab = "Pagel's Lambda", ylim = rev(range(min(y_locs)-0.5, max(y_locs))), main = "Innovation", ylab = "", yaxt = "n")
for(one_group in y_locs) {
    ## Adding the lambda distributions global
    abline(h = y_locs[one_group]+0.25, col = "grey", lwd = 0.5)
    plot_data <- lambda_distributions[[get.data.ID(one_group, type = "global")]][["distance"]][[get.group.ID(one_group)]]
    plot.one.lambda(loc = y_locs[one_group]-0.5, plot_data, col = col[[one_group]])
    ## Adding the position within
      plot_data <- lambda_distributions[[get.data.ID(one_group, type = "within")]][["distance"]][[get.group.ID(one_group)]]
    plot.one.lambda(loc = y_locs[one_group], plot_data, col = adjustcolor(col[[one_group]], alpha = 0.5))
}


```
