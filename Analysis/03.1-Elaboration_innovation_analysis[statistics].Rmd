---
title: "Bird beak's elaboration and innovation"
author: "Thomas Guillerme"
date: "`r Sys.Date()`"
bibliography: references.bib
output:
  html_document:
    fig_width: 8
    fig_height: 8
---

This section contains the code for reproducing the analyses. To get the details, refer to [`dispRity` vignette](link_to_projection_vignette).
This script take around 6 minutes to compile.

```{r, eval = TRUE, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE, print = FALSE}
library(dispRity)
```

# Measuring ellipse's statistics

For each group, we can calculate:

 * It's (dis)alignment relative to the the phylogeny
 * It's distance from the centroid of the phylogeny
 * It's angles sd
 * It's orientation (angle) relative to the whole phylogeny
 * Whether that orientation is significant


# Loading the data

```{r, eval = FALSE, echo = FALSE}
## Load the data for all birds
load(file = "../Data/Processed/shapespace_allbirds_lvl_superorder_order.rda")
## Select the data
shapespace_allbirds <- shapespace_allbirds_lvl_superorder_order[[1]]$space
## Clean garbage
rm(shapespace_allbirds_lvl_superorder_order)

## Load the covar
load(file = "../Data/Processed/shapespace_allbirds_lvl_superorder_order.MCMCglmm")
shapespace_allbirds_posteriors <- shapespace_allbirds_lvl_superorder_order[[1]]
rm(shapespace_allbirds_lvl_superorder_order)

## Get the levels
phylo_lvl <- which(MCMCglmm.levels(shapespace_allbirds_posteriors) == "animal")
super_lvl <- grep("level1_", MCMCglmm.levels(shapespace_allbirds_posteriors))
order_lvl <- grep("level2_", MCMCglmm.levels(shapespace_allbirds_posteriors))

## Create the subset for all birds
all_birds_shapespace <- MCMCglmm.subsets(
      data          = shapespace_allbirds,
      posteriors    = shapespace_allbirds_posteriors,
      group         = MCMCglmm.levels(shapespace_allbirds_posteriors)[c(super_lvl, order_lvl, phylo_lvl)],
      rename.groups = c(levels(shapespace_allbirds$level1)[-1], levels(shapespace_allbirds$level2)[-1], "phylogeny")) #[-1] is because the first level is ""
## Clean garbage
rm(shapespace_allbirds_posteriors)


## Load the covar
load(file = "../Data/Processed/shapespace_passeriformes.MCMCglmm")
shapespace_passeriformes_posteriors <- shapespace_passeriformes[[1]]
rm(shapespace_passeriformes)
## Load the data for the passeriformes
load(file = "../Data/Processed/shapespace_passeriformes_two_levels.rda")
## Select the data
shapespace_passeriformes <- shapespace_passeriformes_two_levels[[1]]$space
## Clean garbage
rm(shapespace_passeriformes_two_levels)

## Get the levels
phylo_lvl <- which(MCMCglmm.levels(shapespace_passeriformes_posteriors) == "animal")
suborder_lvl <- grep("level1_", MCMCglmm.levels(shapespace_passeriformes_posteriors))
family_lvl <- grep("level2_", MCMCglmm.levels(shapespace_passeriformes_posteriors))

## Create the subset for all birds
passeriformes_shapespace <- MCMCglmm.subsets(
      data          = shapespace_passeriformes,
      posteriors    = shapespace_passeriformes_posteriors,
      group         = MCMCglmm.levels(shapespace_passeriformes_posteriors)[c(suborder_lvl, family_lvl, phylo_lvl)],
      rename.groups = c(levels(shapespace_passeriformes$level1)[-1], levels(shapespace_passeriformes$level2)[-1], "Passeriformes")) #[-1] is because the first level is ""
## Clean garbage
rm(shapespace_passeriformes_posteriors)
```

```{r, eval = FALSE, echo = FALSE}
## Creating the nested levels subgroups
make.nested.subset <- function(group, data, group.data) {
    ## Get the subsets within the group
    level2_groups <- as.character(unique(group.data$level2[group.data$level1 == group]))
    if(any(empty <- level2_groups == "")) {
        level2_groups <- level2_groups[-which(empty)]
    }
    if(length(level2_groups) < 1) {
        return(NULL)
    }
    ## Create a subset
    return(get.subsets(data, subsets = c(level2_groups, group)))
}

## Get the subgroups for all_birds
all_birds_shapespace_subgroups <- lapply(as.list(levels(shapespace_allbirds$level1)[-1]), make.nested.subset, data = all_birds_shapespace, group.data = shapespace_allbirds)
names(all_birds_shapespace_subgroups) <- levels(shapespace_allbirds$level1)[-1]
## Get the subgroups for the passeriformes
passeriformes_shapespace_subgroups <- lapply(as.list(levels(shapespace_passeriformes$level1)[-1]), make.nested.subset, data = passeriformes_shapespace, group.data = shapespace_passeriformes)
names(passeriformes_shapespace_subgroups) <- levels(shapespace_passeriformes$level1)[-1]
```

### Groups compared to the phylogeny

```{r, eval = FALSE, echo = FALSE}
source("../Functions/stats.utilities.R")

# ## Fucked up thing happening here:
# cd("~/Packaging/dispRity/")
# load_all()

## General measurement
all_birds_all_levels <- ellipse.stats(all_birds_shapespace)
passeriformes_all_levels <- ellipse.stats(passeriformes_shapespace)

## Nested measurements
all_birds_nested_levels <- lapply(all_birds_shapespace_subgroups, ellipse.stats)
passeriformes_nested_levels <- lapply(passeriformes_shapespace_subgroups, ellipse.stats)

## Big measurements list
ellipses_stats <- list("all_birds" = all_birds_all_levels)
ellipses_stats <- c(ellipses_stats, all_birds_nested_levels)
ellipses_stats$Passeriformes <- passeriformes_all_levels
ellipses_stats <- c(ellipses_stats, passeriformes_nested_levels)

save(ellipses_stats, file = "../Data/Processed/ellipses_stats.rda")
```

And here are the full results! Here's what's in each column:
 
 * **Group**: the name of the group (a random term of the model), the focal VCV
 * **Comparison**: to which group are the VCV compared (the group is either one or two levels higher)
 * **n**: number of species
 * **distance**: the distance between the focal and the comparison group's centers
 * **ellipse sd**: the standard deviation of the angles in the the focal VCV distribution
 * **disalignment**: the disalignment of the group compared to the focal group (0 = aligned), with the 95% CI
 * **orthogonality**: the orthogonality amount between both groups (0 = parallel, 1 = orthogonal), with the 95% CI
 * **Post. prob.**: the posterior probability of the orthogonality in the focal group being different from the comparison one (with the 95% CI estimated from the randomised posterior probabilities)

```{r, eval = TRUE, echo = FALSE}
load("../Data/Processed/ellipses_stats.rda")
source("../Functions/stats.utilities.R")

## Sorting all results
all_results <- do.call(rbind, lapply(ellipses_stats[-12], table.stats)) ## Droping the Meliphagoidea (single group)
rownames(all_results) <- NULL

write.csv(all_results, "../Data/Processed/ellipses.stats.csv")
knitr::kable(all_results)
```

<!-- length(which(all_results[which(all_results[,"Post. prob."] >= 0.95), ]$orthogonality > 0.5)) -->


```{r, eval = TRUE, echo = FALSE, fig.height = 20, fig.width = 8}
#TODO: make the groups nested in the fable

pdf("../Manuscript/Figures/orthogonality.results.pdf", width = 6, height = 15)
source("../Functions/ploting.utilities.R")
## Plot the orthogonality into context
orthogonality <- all_results[, c(1:2, 9:14, 3, 5)]

## Group per level
super_orders <- orthogonality[c(1:8), ]
orders <- orthogonality[c(36:60), ]
orders_n2 <- orthogonality[c(9:35), ]
sub_orders <- orthogonality[c(61:66), ]
families <- orthogonality[c(90:110), ]
families_n2 <- orthogonality[c(67:89), ]

## Sort each level by orthogonality score
ortho.sort <- function(data) {
    return(data[order(data$orthogonality, decreasing = TRUE), , drop = FALSE])
}
## Plotting table (with the sorted orthogonality)
plot_table <- rbind(ortho.sort(super_orders),
                    ortho.sort(orders),
                    ortho.sort(sub_orders),
                    ortho.sort(families))
colours <- c(rep(gg.color.hue(4)[1], nrow(super_orders)),
             rep(gg.color.hue(4)[2], nrow(orders)),
             rep(gg.color.hue(4)[3], nrow(sub_orders)),
             rep(gg.color.hue(4)[4], nrow(families)))

## Adding starts here and there
get.signif <- function(prob) {
    if(prob >= 0.99) {
        return("***")
    } else {
        if(prob >= 0.95) {
            return("**")
        } else {
            if(prob >= 0.90) {
                return("*")
            } else {
                if(prob >= 0.80) {
                    return(".")
                } else {
                    return("")
                }
            }
        }
    }
}
add.stars <- function(data, counter, shift = 0, total, ...) {
    text(data[3] + 0.03, (total+1)-counter + shift + 0.2, labels = get.signif(data[6]), cex = 1, ...)   
}
add.line <- function(data, counter, shift = 0, total, ...) {
    lines(matrix(c(data[4:5], rep((total+1)-counter + shift, 2)), 2, 2), ...)
    points(data[3], (total+1)-counter + shift, pch = 19, ...)
}


## Add the number of species and sd to the group names
convert.spaces <- function(x, max) {
    shifts <- max-nchar(as.character(x))
    if(shifts > 0) {
        return(paste(c(x, rep(" ", shifts)), collapse = ""))
    } else {
        return(x)
    }
}
group_names <- paste0(plot_table$Group, "(n = ", sapply(plot_table$n, convert.spaces, max = 4), " ; sd = ", sapply(round(plot_table$`ellipse sd`, 2), convert.spaces, max = 5), ")")

plot_order <- 1:60
## Nestedness bit (not finished)
# plot_order <- integer()
# ## Super-orders
# for(i in 1:6) {
#     plot_order <- c(plot_order, i) 
#     sub_groups <- which(plot_table$Comparison == plot_table$Group[plot_order[length(plot_order)]])
#     if(length(sub_groups)) {
#         plot_order <- c(plot_order, sub_groups)
#     }
# }
# ## Sub-orders
# for(i in 34:39) {
#     plot_order <- c(plot_order, i) 
#     sub_groups <- which(plot_table$Comparison == plot_table$Group[plot_order[length(plot_order)]])
#     if(length(sub_groups)) {
#         plot_order <- c(plot_order, sub_groups)
#     }
# }


## Plot frame
par(mar = c(5, 17, 4, 2))
plot(NULL, yaxt = "n", xaxt = "n", ylab = "", xlab = "orthogonality", ylim = c(1,nrow(plot_table)), xlim = c(0,1))
abline(v = 0.5, lwd = 0.5, col = "grey")
abline(v = 0.75, lty = 2, col = "grey", lwd = 0.5)
axis(2, at = nrow(plot_table):1, labels = group_names[plot_order], las = 2)
axis(1, at = c(0, 0.5, 1), labels = c(0, 0.5, 1))
## Adding the results
for(i in 1:nrow(plot_table)) {
    add.line (plot_table[plot_order[i], ], counter = i, col = colours[plot_order[i]], total = nrow(plot_table))
    add.stars(plot_table[plot_order[i], ], counter = i, col = colours[plot_order[i]], total = nrow(plot_table))
}

## Adding the n2 results
orders_n2_plot <- orders_n2[match(orders[order(orders$orthogonality, decreasing = TRUE), ]$Group, orders_n2$Group), ]
families_n2_plot <- families_n2[match(families[order(families$orthogonality, decreasing = TRUE), ]$Group, families_n2$Group), ]
for(i in 1:nrow(orders_n2_plot)) {
    add.line(orders_n2_plot[i, ], shift = -1/3, counter = i+nrow(super_orders), col = adjustcolor(colours[i+nrow(super_orders)], alpha.f = 1/3), total = nrow(plot_table))
    add.stars(orders_n2_plot[i, ], shift = -1/3, counter = i+nrow(super_orders), col = adjustcolor(colours[i+nrow(super_orders)], alpha.f = 1/3), total = nrow(plot_table))
}
for(i in 1:nrow(orders_n2)) {
    add.line(families_n2_plot[i, ], shift = -1/3, counter = i+(nrow(plot_table)-nrow(families)), col = adjustcolor(colours[i+(nrow(plot_table)-nrow(families))], alpha.f = 0.5), total = nrow(plot_table))
    add.line(families_n2_plot[i, ], shift = -1/3, counter = i+(nrow(plot_table)-nrow(families)), col = adjustcolor(colours[i+(nrow(plot_table)-nrow(families))], alpha.f = 0.5), total = nrow(plot_table))
}

legend("topleft", legend = c("Super orders (vs. phylogeny)", "Orders (vs. super orders)", "Orders (vs. phylogeny)", "Suborders (vs. passeriformes)", "Families (vs. suborders)", "Families (vs. passeriformes)"), col = c(gg.color.hue(4)[1], gg.color.hue(4)[2], adjustcolor(gg.color.hue(4)[2], alpha.f = 1/3), gg.color.hue(4)[3], gg.color.hue(4)[4], adjustcolor(gg.color.hue(4)[4], alpha.f = 1/3)), pch = 19, lty = 1, cex = 0.8)
dev.off()
```

Distribution of the VCV ellipses' orthogonality for all the groups compared to the ellipse of their parent clade (or n-2). 
For the posterior probabilities: . >= 0.8; * >= 0.9; ** >= 0.95; *** >= 0.99.


```{r, echo = FALSE, eval = TRUE}
## Quick load
load(file = "../Data/Processed/shapespace_allbirds_lvl_superorder_order_results_list.rda")
results <- shapespace_allbirds_lvl_superorder_order_results_list
rm(shapespace_allbirds_lvl_superorder_order_results_list)

## Distribution of elaboration and innovation at the species level
elaboration_species      <- get.disparity(get.subsets(results$super_results_phylo$position, subsets = "phylogeny"), concatenate = FALSE)[[1]]
innovation_species       <- get.disparity(get.subsets(results$super_results_phylo$distance, subsets = "phylogeny"), concatenate = FALSE)[[1]]

## Distribution of elaboration and innovation at the group level
scale.group <- function(X) return(X/max(X))
elaboration_super_orders <- lapply(get.disparity(results$super_results_between$position, concatenate = FALSE), scale.group)
innovation_super_orders  <- lapply(get.disparity(results$super_results_between$distance, concatenate = FALSE), scale.group)
elaboration_orders       <- lapply(get.disparity(results$order_results_between$position, concatenate = FALSE), scale.group)
innovation_orders        <- lapply(get.disparity(results$order_results_between$position, concatenate = FALSE), scale.group)
elaboration_group <- rbind(do.call(rbind, elaboration_super_orders), do.call(rbind, elaboration_orders))
innovation_group <- rbind(do.call(rbind, innovation_super_orders), do.call(rbind, innovation_orders))

## Measuring the area under the curves
elaboration_species_auc <- apply(elaboration_species, 2, area.density)
innovation_species_auc <- apply(innovation_species, 2, area.density)
elaboration_group_auc <- apply(elaboration_group, 2, area.density)
innovation_group_auc <- apply(innovation_group, 2, area.density)

pdf("../Manuscript/Figures/Relative_EI.pdf", height = 8, width = 8)
par(mfrow = c(2,2))
plot.density(species = c(elaboration_species),
             group   = c(unlist(elaboration_super_orders), unlist(elaboration_orders)),
             xlab    = "relative elaboration", scale.x = TRUE,
             ylab    = "density",
             main    = "A - Total posterior elaboration per group (scaled)\nand per species")
legend("topright", lty = 1, legend = c("species", "groups"), col = c("blue", "orange"))
plot.density(species = c(innovation_species),
             group   = c(unlist(innovation_super_orders), unlist(innovation_orders)),
             xlab    = "relative innovation", scale.x = TRUE,
             ylab    = "density",
             main    = "B - Total posterior innovation per group (scaled)\nand per species")
plot.density(elaboration_species_auc, elaboration_group_auc, scale.x = FALSE, col = c("blue", "orange"), ylab = "density",
             xlab = "Posterior area under the curve (elaboration)",
             main = paste0("C - Difference in amounts of elaboration\nper group or per species\nBhattacharyya coefficient = ",
                           round(bhatt.coeff(elaboration_species_auc, elaboration_group_auc), 3)))
plot.density(innovation_species_auc, innovation_group_auc, scale.x = FALSE, col = c("blue", "orange"), ylab = "density",
             xlab = "Posterior area under the curve (innovation)",
             main = paste0("D - Difference in amounts of innovation\nper group or per species\nBhattacharyya coefficient = ",
                           bhatt.coeff(innovation_species_auc, innovation_group_auc)))
dev.off()
```