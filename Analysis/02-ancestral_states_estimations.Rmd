---
title: "Ancestral traits estimations"
author: "Thomas Guillerme"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_width: 12
    fig_height: 6
---

```{r}
library(ape)
library(castor)
```

# Ancestral traits estimations

 - [ ] Run the ancestral states estimations on different trees to have a distribution rather than point estimates. Three options here to build the fuzzy trait space:
    * [ ] **Fuzzy average**: run the ace on multiple trees and use their multiple averages as the ace distribution.
    * [ ] **Random fuzzy**: run the ace on multiple trees and randomly sample one value from the estimation
    * [ ] **Fuzzy distribution**: run the ace on multiple trees and sample *n* random values from the estimation
 - [ ] Combine the data together into `dispRity` objects

## Loading the data

```{r}
load(file = "../Data/Processed/trees_list.rda")
load(file = "../Data/Processed/spaces_list.rda")
```

## Running the ancestral states

We can estimate the ancestral characters using the `ape::ace` function.
Here we define "ancestral characters" as "the position of a node of the tree in the ordinated beak shape space".
We will assume that position in shape space evolves under a Brownian Motion that is only dependent on time. I.e. the longer the evolutionary time between two elements (tips or nodes), the more variance there is in position in shape space.

> Note that this is not the only assumption we can make. One other correct one would be to scale the branch length by amount of changes (cf. by evolutionary time). This way, the longer the branch (the longer the molecular changes) between two elements, the more variance.

We will also assume that the position in the trait space are independent (i.e. position on the first axis of the trait space is not related to the position on the second axis, etc...).

> This assumption can also be relaxed pretty easily using a multi trait BM. However, it is rather defendable to not do here since the ordination by definition makes the axis orthogonal and thus non-correlated.

From each ancestral character estimation, we will extract either:
 * [ ] the character value with the highest likelihood
 * [ ] one random character value from within the 95% confidence interval
 * [ ] ten random character values from the 95% CI


```{r}
# ##DEBUG
# matrix <- matrix(rnorm(100), 10, 5)
# trees <- rmtree(7, 10)
# trees <- lapply(trees, function(tree) {tree$node.label <- paste0("n", 1:Nnode(tree)); return(tree)})
# class(trees) <- "multiPhylo"
# tree <- trees[[1]]
# rownames(matrix) <- tree$tip.label

## Function for running the ace on the whole matrix (i.e. for all the traits)
one.ace <- function(traits, tree) {
    cat(".")
    results <- ace(traits, tree)
    results$labels <- tree$node.label
    return(results)
}
run.full.ace <- function(tree, matrix) {
    cat("Estimating one matrix:")
    ace_results <- apply(matrix, 2, one.ace, tree)
    cat("Done\n")
    return(ace_results)
}

# ##DEBUG
# all_results <- lapply(trees, run.full.ace, matrix)
# ace_result <- all_results[[1]]

## Function for extracting the ace values of interest
#' @param ace the output from run.full.ace
#' @param what either "max" for the most likely value, or any integer for a number of random values (e.g. 1 or 10)
#' @param sampling the sampling distribution can be "uniform" (default) or "normal"0
#' 
## Extracting random values from the ace_results 95% (uniform or normal)
fun.uniform <- function(ci95, what) {
    return(runif(what, min = ci95[1], max = ci95[2]))
}
fun.normal <- function(ci95, what) {
    return(rnorm(what, mean = mean(x), sd = sd(x)/3))
}
extract.ace <- function(ace_result, what, sampling = "uniform", matrix) {
    ## Switching between both type of results
    if(what == "max") {
        ## Extracting the most likely states
        node_states <- do.call(cbind, lapply(ace_result, function(x) return(x$ace)))
        rownames(node_states) <- ace_result[[1]]$labels
        return(rbind(matrix, node_states))
    } else {
        ## Toggle the sampling function
        fun.sample <- ifelse(sampling == "uniform", fun.uniform, fun.normal)
        trait_results <- lapply(ace_result, function(trait, fun.sample, what) apply(trait$CI95, 1, fun.sample, what = what), fun.sample, what)

        if(what == 1) {
            ## Return single samples
            node_states <- do.call(cbind, trait_results)
            rownames(node_states) <- ace_result[[1]]$labels
            return(rbind(matrix, node_states))            
        } else {
            ## Return multiple samples
            node_states <- list()
            for(i in 1:what) {
                node_states[[i]] <- do.call(cbind, lapply(trait_results, function(X, i) return(X[i, ]), i))
                rownames(node_states[[i]]) <- ace_result[[1]]$labels
            }
            return(lapply(node_states, function(X, matrix) rbind(matrix, X), matrix))
        }
    }
}
# ## DEBUG
# #all_trees_max_lik <- lapply(all_results, extract.ace, what = "max", matrix = matrix)
```

```{r, eval = TRUE}
## Running the ace for all the characters for both spaces
psita_ace <- lapply(trees_list$psittaciformes, run.full.ace,
                    matrix = spaces_list$psittaciformes)
chara_ace <- lapply(trees_list$charadriiformes, run.full.ace,
                    matrix = spaces_list$charadriiformes)
save(psita_ace, file = "../Data/Processed/psita_ace.rda")
save(chara_ace, file = "../Data/Processed/chara_ace.rda")
```



## Make the dispRity objects