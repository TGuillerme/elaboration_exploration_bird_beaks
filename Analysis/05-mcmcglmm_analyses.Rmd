---
title: "05 - MCMCglmm analyses"
author: "Thomas Guillerme"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_width: 12
    fig_height: 6
---

# Elaboration/exploration analyses

```{r}
## Loading the packages and data
library(dispRity)
load(file = "../Data/Processed/disparity_matrices.rda")
load(file = "../Data/Processed/trees_list.rda")
load(file = "../Data/Processed/spaces_list.rda")
load(file = "../Data/Processed/tmp_simple_matrices.rda")
```

The whole discussion from last meeting was on how to determine the axis of elaboration to measure the elaboration/exploration metrics.

Here I am going to explore the major axis from the var-covar matrix from (`MCMCglmm::...()$VCV)` and do this TODO list:

 - [ ] rerun part 1 to 4 using the beak PCA *with* centroid size (`"2020_08_07_MMB_MORPHO_FORMSPACE_FULL.rds"`)
 - [ ] Use the 95% axis from the mcmcglmm vcv matrix (check [here](https://github.com/andbeck/mcmc-plus-tensor))
 - [ ] Use the 95% axis from a vcv matrix from a MANOVA (h-matrix/e-matrix)
 - [ ] Use the x axis from the Phylo-PCA or a Phylo aligned PCA (`geomorph::gm.prcomp()`; see section 3 and 3(4) [here](https://cran.r-project.org/web/packages/geomorph/vignettes/geomorph.PCA.html))

# Testing with the plethodon dataset

## Normal PCA

```{r}
library(geomorph)

## Loading the landmarks and the tree
data(plethspecies) 

## For the sake of visualisation I'm just going to rename everything from A to I
dimnames(plethspecies$land)[[3]] <- plethspecies$phy$tip.label <- LETTERS[1:9]

## Procrustes blabla
procrustes <- gpagen(plethspecies$land, print.progress = F)
tree <- plethspecies$phy
## Making the tree ultrametric
tree$edge.length[which(tree$edge[,2] == 7)] <- tree$edge.length[which(tree$edge[,2] == 7)] + 0.000001
```

```{r}
## PCA (with plotted tree)
pca <- gm.prcomp(procrustes$coords, phy = tree)
plot(pca, phylo = TRUE, main = "PCA trait space\n(tree and nodes are just plotted)")
```

This is just the normal PCA, nothing special here.

## Phylo corrected PCA

```{r}
## Phylo PCA
GLS_pca <- gm.prcomp(procrustes$coords, phy = tree, GLS = TRUE)
plot(GLS_pca, phylo = TRUE, main = "PCA trait space\n(with phylo correction)")
```

This one is following [Revell 2009](https://onlinelibrary.wiley.com/doi/full/10.1111/j.1558-5646.2009.00804.x) procedure that is basically applying a phylogenetic correction to the data while ordinating it.
I think this is the one that doesn't make too much sense (see the story of doing "phylo corrected log").
But I need to double check.

## Phylo aligned PCA

```{r}
## Phylo aligned PCA
Pa_pca <- gm.prcomp(procrustes$coords, phy = tree, align.to.phy = TRUE)
plot(Pa_pca, phylo = TRUE, main = "PCA trait space\n(with phylo aligned)")
```

This one is the new [Collyer and Adams 2020](https://www.researchgate.net/profile/Michael-Collyer-4/publication/344900621_Phylogenetically_Aligned_Component_Analysis/links/5fa4123b458515157bec1bcb/Phylogenetically-Aligned-Component-Analysis.pdf) method where the phylogenetic signal is "distilled in the first PC axes".
I need to double check that one as well.

## MCMCglmm

```{r, eval = FALSE, print = FALSE}
library(MCMCglmm)
## Running a MCMCglmm model on with all the traits in the PCA
morpho <- as.data.frame(pca$x)
mcmcglmm_data <- data.frame(pca$x, animal = rownames(pca$x))
tree_inverse <- inverseA(tree)$Ainv
priors <- list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V = 1, nu = 0.002)))

phenotype <- pca$x[,1, drop = FALSE]

# simulate phylogenetic and residual effects with unit variance
test.data <- data.frame(phenotype = phenotype, animal = row.names(phenotype))

model1 <- MCMCglmm(fixed = Comp1 ~ 1, random = ~animal, pedigree = tree,
 data = test.data, prior = priors, verbose = TRUE, nitt = 1300, burnin = 300, thin = 1)












test <- MCMCglmm(fixed = cbind(morpho$Comp1, morpho$Comp2) ~ Comp-1, random = ~species, pedigree = tree, prior = priors, data = morpho, verbose = TRUE, nitt = 1300, burnin = 300, thin = 1)






data(bird.families) 

phylo.effect <- rbv(bird.families, 1, nodes="TIPS") 
phenotype <- phylo.effect + rnorm(dim(phylo.effect)[1], 0, 1)  



plot(model2$VCV)




pca$x ~ pca$x[,1]-1, random = ~
family = c(rep("gaussian"), ncol(pca$x))


formula = 
MCMCglmm::MCMCglmm(fixed = formula, random = mulTree.data$random.terms, pedigree = mulTree.data$phy[[tree]], prior = priors, data = mulTree.data$data, verbose = FALSE, nitt = parameters[1], thin = parameters[2], burnin = parameters[3])



model1.1<-MCMCglmm(cbind(trait1, trait2, trait3, trait4, trait5)  ~ trait-1, random=~us(trait):sire, rcov=~us(trait):units, family=c("gaussian","gaussian","gaussian","gaussian", "gaussian"), prior=prior1, data=data1[[1]], verbose=FALSE, burnin=50000, thin=100, nitt=150000)

print("ha")
```

Here we used [Robinson and Beckerman 2013](https://onlinelibrary.wiley.com/doi/abs/10.1111/ele.12047) to get the VCV matrix that we can use to get the base vector.


# Comparing the projection rejection profiles

For each method we can measure the projection and rejections using the following base vectors:

 - [ ] The 95% quantile of the PCA
 - [ ] The MCMCglmm main axis on the PCA
 - [ ] The first axis (range unit-scaled) of the PCA
 - [ ] The first axis (range unit-scaled) of the GLS PCA
 - [ ] The first axis (range unit-scaled) of the Pa PCA

```{r}
## Utility functions
project.reject <- function(data, vector, absolute = FALSE) {

    ## Get the projection
    projection <- projections(
          matrix = data, 
          point1 = vector[1,],
          point2 = vector[2,],
          measure = "position")

    ## Get the rejection
    rejection <- projections(
          matrix = data, 
          point1 = vector[[1]],
          point2 = vector[[2]],
          measure = "distance")

    ## Combine and out
    if(absolute) {
      results <- cbind(abs(projection), rejection)
    } else {
      results <- cbind(projection, rejection)
    }
    rownames(results) <- rownames(data)
    return(results)
}
plot.project.reject <- function(results, xlab = "Elaboration", ylab = "Exploration", col = "black", main = "Project/Reject") {

    pchs <- 19
    colours <- "black"

    plot(results, xlab = xlab, ylab = ylab, col = colours, pch = pchs, main = main, cex = 0.2)
    text(results, rownames(results), pos = 2)
}
plot.ord <- function(ordination, main, vector) {
    plot(ordination[, c(1:2)], pch = 19, cex = 0.2, main = main)
    text(ordination[, c(1:2)], rownames(ordination), pos = 2)
    lines(vector[, c(1:2)], lwd = 2)
}
```

```{r, fig.height = 6, fig.width = 12}
par(mfrow = c(1,2))
## The 95% quantile of the PCA
vector <- apply(pca$x, 2, quantile, prob = c(0.025, 0.975))
results <- project.reject(pca$x, vector)

plot.ord(pca$x, vector, main = "PCA")
plot.project.reject(results, main = "Vector: pca 95%")
```

```{r}
# par(mfrow = c(1,2))
# ## The MCMCglmm main axis on the PCA
# vector <- rbind("point1" = rep(0, ncol(Pa_pca$x)),
#                 "point2" = c(max(Pa_pca$x[,1]),
#                              rep(0, ncol(Pa_pca$x)-1)))
# results <- project.reject(Pa_pca$x, vector)

# plot.ord(Pa_pca$x, vector, main = "Pa PCA")
# plot.project.reject(results, main = "Vector: Pa pca PC1")

print("ha")
```


```{r, fig.height = 6, fig.width = 12}
par(mfrow = c(1,2))
## The first axis (range unit-scaled) of the PCA
vector <- rbind("point1" = rep(0, ncol(pca$x)),
                "point2" = c(max(pca$x[,1]),
                             rep(0, ncol(pca$x)-1)))
results <- project.reject(pca$x, vector)

plot.ord(pca$x, vector, main = "PCA")
plot.project.reject(results, main = "Vector: PC1")
```

```{r}
par(mfrow = c(1,2))
## The first axis (range unit-scaled) of the GLS PCA
vector <- rbind("point1" = rep(0, ncol(GLS_pca$x)),
                "point2" = c(max(GLS_pca$x[,1]),
                             rep(0, ncol(GLS_pca$x)-1)))
results <- project.reject(GLS_pca$x, vector)

plot.ord(GLS_pca$x, vector, main = "GLS PCA")
plot.project.reject(results, main = "Vector: GLS pca PC1")
```


```{r}
par(mfrow = c(1,2))
## The first axis (range unit-scaled) of the Pa PCA
vector <- rbind("point1" = rep(0, ncol(Pa_pca$x)),
                "point2" = c(max(Pa_pca$x[,1]),
                             rep(0, ncol(Pa_pca$x)-1)))
results <- project.reject(Pa_pca$x, vector)

plot.ord(Pa_pca$x, vector, main = "Pa PCA")
plot.project.reject(results, main = "Vector: Pa pca PC1")
```
