---
title: "05 - MCMCglmm analyses"
author: "Thomas Guillerme"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_width: 12
    fig_height: 6
---

# Elaboration/exploration analyses

```{r}
## Loading the packages and data
library(dispRity)
load(file = "../Data/Processed/disparity_matrices.rda")
load(file = "../Data/Processed/trees_list.rda")
load(file = "../Data/Processed/spaces_list.rda")
load(file = "../Data/Processed/tmp_simple_matrices.rda")
```

The whole discussion from last meeting was on how to determine the axis of elaboration to measure the elaboration/exploration metrics.

Here I am going to explore the major axis from the var-covar matrix from (`MCMCglmm::...()$VCV)` and do this TODO list:

 - [ ] rerun part 1 to 4 using the beak PCA *with* centroid size (`"2020_08_07_MMB_MORPHO_FORMSPACE_FULL.rds"`)
 - [ ] Use the 95% axis from the mcmcglmm vcv matrix (check [here](https://github.com/andbeck/mcmc-plus-tensor))
 - [ ] Use the 95% axis from a vcv matrix from a MANOVA (h-matrix/e-matrix)
 - [ ] Use the x axis from the Phylo-PCA or a Phylo aligned PCA (`geomorph::gm.prcomp()`; see section 3 and 3(4) [here](https://cran.r-project.org/web/packages/geomorph/vignettes/geomorph.PCA.html))

# Testing with the plethodon dataset

## Normal PCA

```{r}
library(geomorph)

## Loading the landmarks and the tree
data(plethspecies) 

## For the sake of visualisation I'm just going to rename everything from A to I
dimnames(plethspecies$land)[[3]] <- plethspecies$phy$tip.label <- LETTERS[1:9]

## Procrustes blabla
procrustes <- gpagen(plethspecies$land, print.progress = F)
tree <- plethspecies$phy
## Making the tree ultrametric
tree$edge.length[which(tree$edge[,2] == 7)] <- tree$edge.length[which(tree$edge[,2] == 7)] + 0.000001
```

```{r}
## PCA (with plotted tree)
pca <- gm.prcomp(procrustes$coords, phy = tree)
plot(pca, phylo = TRUE, main = "PCA trait space\n(tree and nodes are just plotted)")
```

This is just the normal PCA, nothing special here.

## Phylo corrected PCA

```{r}
## Phylo PCA
GLS_pca <- gm.prcomp(procrustes$coords, phy = tree, GLS = TRUE)
plot(GLS_pca, phylo = TRUE, main = "PCA trait space\n(with phylo correction)")
```

This one is following [Revell 2009](https://onlinelibrary.wiley.com/doi/full/10.1111/j.1558-5646.2009.00804.x) procedure that is basically applying a phylogenetic correction to the data while ordinating it.
I think this is the one that doesn't make too much sense (see the story of doing "phylo corrected log").
But I need to double check.

## Phylo aligned PCA

```{r}
## Phylo aligned PCA
Pa_pca <- gm.prcomp(procrustes$coords, phy = tree, align.to.phy = TRUE)
plot(Pa_pca, phylo = TRUE, main = "PCA trait space\n(with phylo aligned)")
```

This one is the new [Collyer and Adams 2020](https://www.researchgate.net/profile/Michael-Collyer-4/publication/344900621_Phylogenetically_Aligned_Component_Analysis/links/5fa4123b458515157bec1bcb/Phylogenetically-Aligned-Component-Analysis.pdf) method where the phylogenetic signal is "distilled in the first PC axes".
I need to double check that one as well.


## MCMCglmm

```{r, eval = TRUE, print = TRUE, echo = FALSE}
library(MCMCglmm)

## Add the animal and clade (which is more like a clade + a grade) column to data
mcmcglmm_data <- as.data.frame(pca$x)
mcmcglmm_data <- cbind(mcmcglmm_data,
                       clade = as.factor(c(rep("clade", 5), rep("grade", 4))),
                       animal = rownames(pca$x))
## Selecting the traits that have a non zero variance (0 =< 1e-6: for some reason that's what MCMCglmm likes: TODO:fix: see bugs with Choleski decomposition and rounding estimates errors in MCMCglmm)
select_traits <- apply(pca$x, 2, var) > 2e-5

## TEST WITH ONLY THREE TRAITS
select_traits <- c(1,1)

## MCMC params
MCMCparams <- list(nitt   = 110000,
                   burnin = 10000,
                   thin   = 100)

## Making the fixed terms formula
#TODO: do some wrapping to get all the variable names automatically
formula_noclade = cbind(Comp1, Comp2) ~ trait-1
formula_clade = cbind(Comp1, Comp2) ~ trait:clade-1

## Base model
#GT: The simplest model simply estimates the overal covariance matrix for the whole data set
## The base model residuals
base_residuals <- ~ us(trait):units
## Running the base model
model_base <- MCMCglmm(fixed  = formula_noclade,
                       family = rep("gaussian", sum(select_traits)),
                       rcov   = base_residuals,
                       data   = mcmcglmm_data,
                       nitt   = MCMCparams$nitt,
                       burnin = MCMCparams$burnin,
                       thin   = MCMCparams$thin)

## Clade model
#GT: The next model, still without phylogeny, involves modelling clade effect. Note that we are using clade both in the fixed effects and in the random effects. The random effects relate to covariances and main effects to means
## The residuals for the clade model
#TODO: generate automatically from the levels of the data
clade_residuals <- ~ us(at.level(clade,1):trait):units + us(at.level(clade,2):trait):units
## The clade model
model_clade <- MCMCglmm(fixed  = formula_clade,
                        family = rep("gaussian", sum(select_traits)),
                        rcov   = clade_residuals,
                        data   = mcmcglmm_data,
                        nitt   = MCMCparams$nitt,
                        burnin = MCMCparams$burnin,
                        thin   = MCMCparams$thin)
 
## Phylogeny model
#GT: Now we will add phylogeny. To begin with we will not include the clade (gull, plover, sandpiper) effect and instead just partition covariances into phylogenetic and non-phylogenetic effects. At this point the model is becoming more complex and we need to specific a prior.
## Priors for the phylo model
#TODO: select the priors
nu <- 0.002
prior_phylo <- list(R = list(R1 = list(V = diag(sum(select_traits)), nu = nu)),
                    G = list(G1 = list(V = diag(sum(select_traits)), nu = nu)))
## The random terms for the phylo model
random_phylo <- ~ us(trait):animal
## The phylo model
#TODO: this is prone to crash due to random samples in the MCMC (I think it's rounding problems with the Cholesky decomposition)
model_phylo <- MCMCglmm(fixed = formula_noclade,
                        family = rep("gaussian", sum(select_traits)),
                        random = random_phylo,
                        rcov   = base_residuals,
                        prior  = prior_phylo,
                        pedigree = tree,
                        data   = mcmcglmm_data,
                        nitt   = MCMCparams$nitt,
                        burnin = MCMCparams$burnin,
                        thin   = MCMCparams$thin)

## Phylo and clade model
#GT: Now we will add phylogeny with the clade (gull, plover, sandpiper) effect. This model has a single overall phylogenetic effects and clade specific non-phylogenetic effects. Note the changes to the prior specification as well as the main model. This is the model that I would suggest using to test for changes in clade covariances relative to phylogeny to test which clades innovate/elaborate

#TODO: make the priors choice
prior_phylo_clade <- list(R = list(R1 = list(V = diag(sum(select_traits)), nu = nu),
                                   R2 = list(V = diag(sum(select_traits)), nu = nu)), 
                          G = list(G1 = list(V = diag(sum(select_traits)), nu = nu)))


## The phylo+clade model
model_phy_clade <- MCMCglmm(fixed  = formula_clade,
                            family = rep("gaussian", sum(select_traits)),
                            random = random_phylo,
                            rcov   = clade_residuals,
                            prior  = prior_phylo_clade,
                            pedigree = tree,
                            data   = mcmcglmm_data,
                            nitt   = MCMCparams$nitt,
                            burnin = MCMCparams$burnin,
                            thin   = MCMCparams$thin)

## Phylo_clade and clade
#GT: Now we will add phylogeny with phylogenetic and non-phylogenetic clade (gull, plover, sandpiper) effects. This model has a single overall phylogenetic effects and clade specific non-phylogenetic effects. Note the changes to the prior specification as well as the main model. This is the model that I would suggest using to test for changes in clade covariances relative to phylogeny to test which clades innovate/elaborate

## The phylo_clade random terms
random_phylo_clade <- ~ us(at.level(clade,1):trait):animal + us(at.level(clade,2):trait):animal

#TODO: make these priors automatic (again!)
prior_phy_cla_cla <- list(R = list(R1 = list(V = diag(sum(select_traits)), nu = nu),
                                   R2 = list(V = diag(sum(select_traits)), nu = nu)), 
                          G = list(G1 = list(V = diag(sum(select_traits)), nu = nu),
                                   G2 = list(V = diag(sum(select_traits)), nu = nu)))

## The phylo_clade + clade model
model_phy_clade <- MCMCglmm(fixed  = formula_clade,
                            family = rep("gaussian", sum(select_traits)),
                            random = random_phylo_clade,
                            rcov   = clade_residuals,
                            prior  = prior_phy_cla_cla,
                            pedigree = tree,
                            data   = mcmcglmm_data,
                            nitt   = MCMCparams$nitt,
                            burnin = MCMCparams$burnin,
                            thin   = MCMCparams$thin)
```

Here we used [Robinson and Beckerman 2013](https://onlinelibrary.wiley.com/doi/abs/10.1111/ele.12047) to get the VCV matrix that we can use to get the base vector.


# Comparing the projection rejection profiles

For each method we can measure the projection and rejections using the following base vectors:

 - [ ] The 95% quantile of the PCA
 - [ ] The MCMCglmm main axis on the PCA
 - [ ] The first axis (range unit-scaled) of the PCA
 - [ ] The first axis (range unit-scaled) of the GLS PCA
 - [ ] The first axis (range unit-scaled) of the Pa PCA

```{r}
## Utility functions
project.reject <- function(data, vector, absolute = FALSE) {

    ## Get the projection
    projection <- projections(
          matrix = data, 
          point1 = vector[1,],
          point2 = vector[2,],
          measure = "position")

    ## Get the rejection
    rejection <- projections(
          matrix = data, 
          point1 = vector[[1]],
          point2 = vector[[2]],
          measure = "distance")

    ## Combine and out
    if(absolute) {
      results <- cbind(abs(projection), rejection)
    } else {
      results <- cbind(projection, rejection)
    }
    rownames(results) <- rownames(data)
    return(results)
}
plot.project.reject <- function(results, xlab = "Elaboration", ylab = "Exploration", col = "black", main = "Project/Reject") {

    pchs <- 19
    colours <- "black"

    plot(results, xlab = xlab, ylab = ylab, col = colours, pch = pchs, main = main, cex = 0.2)
    text(results, rownames(results), pos = 2)
}
plot.ord <- function(ordination, main, vector) {
    plot(ordination[, c(1:2)], pch = 19, cex = 0.2, main = main)
    text(ordination[, c(1:2)], rownames(ordination), pos = 2)
    lines(vector[, c(1:2)], lwd = 2)
}
```

```{r, fig.height = 6, fig.width = 12}
par(mfrow = c(1,2))
## The 95% quantile of the PCA
vector <- apply(pca$x, 2, quantile, prob = c(0.025, 0.975))
results <- project.reject(pca$x, vector)

plot.ord(pca$x, vector, main = "PCA")
plot.project.reject(results, main = "Vector: pca 95%")
```

```{r, fig.height = 6, fig.width = 12}
par(mfrow = c(1,2))
## The first axis (range unit-scaled) of the PCA
vector <- rbind("point1" = rep(0, ncol(pca$x)),
                "point2" = c(max(pca$x[,1]),
                             rep(0, ncol(pca$x)-1)))
results <- project.reject(pca$x, vector)

plot.ord(pca$x, vector, main = "PCA")
plot.project.reject(results, main = "Vector: PC1")
```

```{r}
par(mfrow = c(1,2))
## The first axis (range unit-scaled) of the GLS PCA
vector <- rbind("point1" = rep(0, ncol(GLS_pca$x)),
                "point2" = c(max(GLS_pca$x[,1]),
                             rep(0, ncol(GLS_pca$x)-1)))
results <- project.reject(GLS_pca$x, vector)

plot.ord(GLS_pca$x, vector, main = "GLS PCA")
plot.project.reject(results, main = "Vector: GLS pca PC1")
```


```{r}
par(mfrow = c(1,2))
## The first axis (range unit-scaled) of the Pa PCA
vector <- rbind("point1" = rep(0, ncol(Pa_pca$x)),
                "point2" = c(max(Pa_pca$x[,1]),
                             rep(0, ncol(Pa_pca$x)-1)))
results <- project.reject(Pa_pca$x, vector)

plot.ord(Pa_pca$x, vector, main = "Pa PCA")
plot.project.reject(results, main = "Vector: Pa pca PC1")
```


```{r}
# par(mfrow = c(1,2))
# ## The MCMCglmm main axis on the PCA
# vector <- rbind("point1" = rep(0, ncol(Pa_pca$x)),
#                 "point2" = c(max(Pa_pca$x[,1]),
#                              rep(0, ncol(Pa_pca$x)-1)))
# results <- project.reject(Pa_pca$x, vector)

# plot.ord(Pa_pca$x, vector, main = "Pa PCA")
# plot.project.reject(results, main = "Vector: Pa pca PC1")

print("ha")
```

